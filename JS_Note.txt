                                            JAVASCRIPT
                                            ----------

What is Javascript?
JavaScript is a high-level, interpreted programming language that is used to add interactivity and dynamic behavior to web pages.
It is one of the core technologies of the World Wide Web and runs on the client side, which means that the code is executed by the
user's web browser rather than the server. This allows developers to create rich and interactive web applications that can update
and change the content in real time without the need for a page refresh.

                JavaScript is a versatile language and can be used for a wide range of tasks, such as form validation, creating
animations and effects, manipulating the Document Object Model (DOM), and making HTTP requests. It can be written in an 
object-oriented, functional, or procedural style, and has a rich set of libraries and frameworks that can be used to simplify
and speed up development.

                Javascript is a programming language which runs on browser and with the introduction of node j.s for the first
time Javascript was able to run outside of the browser world.

JavaScript is not a strongly typed or strictly typed language.

JavaScript was orginally known as Ecma Script(ES).In 2009 ES5 launched and till the date we are using ES6
which is introduced in 2015

Why do we need Javascript?
To create best of web based application or to create the best of backend API servers or to create the bestof SPA's/Hybrid Apps 
Javascript is the one which smoothly blends into which ever way we want it to.

Is Javascript just a programming language?
Javascript is now one of the world's most popular language not because it can perform certain actions but because it's now the
backbone of the most famous frameworks/libraries available to us which makes the constructed software robust than there is barely
anything left which cannot be done on a browser platform

                Angular,React,Node,React Native,Ionic,vue,Next JS,Nest JS,Electron Js,jQuery,Moment JS etc are most famous and
widely used frameworks which we have in todays technological world.


How to run Javascript?
Method-1 : open browser ---> Right click ---> Click inspect ---> Navigate to console ---> type code and enter to get output/result.

Method-2 (Javascript Engine) : Javascript runs on v8 Engine in google chrome.It's single threaded and to totally understand typescript
                               you should know proper working of Javascript.It uses .js extension and in html file <script> tag is used
                               to connect js file with html for browser.

Method-3 (JavaScript file) : create saperate file with extension js and link it to html page inside <script src="---"></script>


OUTPUT/PRINT STATEMENTS
-----------------------
The console.log() is a function in JavaScript that is used to print any kind of variables defined before it or to print any message that
needs to be displayed to the console.

Syntax : console.log(" "); / console.log(variable_name);

Parameters: It accepts a parameter that can be an array, an object, or any message.
Return value: It outputs the value of the given parameter to the console.

Eg: console.log("Hello, Adithya");
    console.log(3+5);


console.warn('Message'); - Similar to console.log(), console.warn() is used to log messages to the console. However, it is often used for
                           logging warning messages. Warning messages indicate potential issues or non-critical problems in your code.
                           They are typically displayed in yellow or with a warning icon in the console, making them stand out.

console.error('Message'); - console.error() is used for logging error messages to the console. Error messages indicate critical issues
                            or errors in your code that need attention. They are usually displayed in red or with an error icon, making
                            them highly visible. Developers often use this for debugging and identifying and fixing errors in their code.

VARIABLES
---------
A variable is a named placeholder that holds data or information. In simpler terms, variables are used to store values that can be used
and manipulated throughout your code. Think of variables as containers that hold different types of data, such as text, numbers, or even
more complex structures.

There are 3 types of variable in JS:

Before ES6 we had only one way of declaring variable : using var . After ES6 they have added two more ways, let and const.

1) var - used to store any values.The var keyword is used to declare a variable.The scope of a var variable is functional scope.
         Problem with var is we can redeclare variable with same name with same datatype multiple times.

2) let - The let keyword is used to declare a variable. same as var but we can't able to redeclare variable with same name instead we 
         can able to change the value stored in variable. This will help by avoiding overriding previous value by mistake.The scope of
         a let variable is block scope.

3) const -The const keyword is used to declare a variable. const value can't able to change after it is initialized. We can't able to 
          only declare const variable, we must have to initialize it. The scope of a const variable is block scope.

Block Scoping: let and const are block-scoped, meaning they are only accessible within the block{} they are defined. var is function-scoped,
               which can lead to unexpected behavior.
               
Re-assignment: const ensures that variables cannot be reassigned, which helps prevent accidental changes to important values.

Note: Variable name are always CASE SENSITIVE eg: var age and var Age are considered as different varibales . we can use _ and $ for 
      variable names.

DATA TYPES IN J.S
-----------------
There are majorly two types of languages. First, one is Statically typed language where each variable and expression type is already
known at compile time. Once a variable is declared to be of a certain data type, it cannot hold values of other data types.

Example: C, C++, Java.

Other is Dynamically typed languages: These languages can receive different data types over time. For example- Ruby, Python, JavaScript, etc.

JavaScript is a dynamically typed (also called loosely typed) scripting language. That is in JavaScript, variables can receive different
data types over time. Datatypes are basically type of data that can be used and manipulated in a program.

Datatypes in javascript are mainly catagorized into two primitive and non-primitive data types

Primitive data types are the most basic data types. They are immutable (i.e., their values cannot be changed) and are stored directly
in the memory location.They can only store single value.
Primitive Data Types are (Number, String, Boolean, Undefined, Null, Symbol, BigInt).

Non-primitive data types are objects that hold references to the memory location where the actual data is stored. Unlike primitive data
types, they are mutable and can be modified.
Non-primitive data types are (Object,Array,functions,Date,RegExp).

Primitive data types  themselves are immutable, meaning that once a primitive value is created, it cannot be altered. However, you can
re-assign the variable to hold a new primitive value because the variable itself is mutable. If you reassign with another value then 
a new memory is assigned with a new address with new value.

1) Numbers: Represent both integer and floating-point numbers. Example: 5, 6.5, 7 etc.
2) String: A string is a sequence of characters enclosed in quotes. In JavaScript, strings can be enclosed within the single(' ') ,  
            double quotes(" ") or backticks(` `). 
           Example: let useName = “Hello GeeksforGeeks”; let numbers = ('1234') etc.
3) Boolean - True/False values eg: let isProductInCart = false.
4) Undefined -A variable that is declared but not assigned a value has the type undefined.
5) Null - null represents the intentional absence of any object value. It's used to indicate "no value." null means no value.We never 
          assign null this is mainly comes as result if the fetching of API is failed or in calculation error.
          eg: let damage = null; 

6) Symbol: Unlike other primitive data types, it does not have any literal form. It is a built-in object whose constructor returns a
        symbol-that is unique. 
7) BigInt: The Bigint type represents the whole numbers that are larger than 253-1. To form a BigInt literal number, you append the
           letter n at the end of the number.

Non-primitive data types, also known as reference types, are more complex structures. They can store collections of values and more
complex entities. They are mutable and are stored by reference. The non-primitive data types are object,Array,function,date,RegExp,Map,
Sets,WeakMaps and WeakSets.

8) object - Objects are non-primitive(complex) data types that allow you to store collections of data. Objects are created using curly 
            braces {}.
            {},[] - objects are collection of data stored as key and value pair
            eg: const personalDetails = {name:"Adithya", age:23, sex:male,qualification:BCA};
                const evenNum = {2,4,6,8,10};
                const details = {{},{},{},[]}; - nested objects.

8) Arrays are a type of object used to store multiple values in a single variable, created using square brackets [].


Note: Use typeof operator to check datatype of a variable.
        eg: console.log(typeof username);


CONCATINATION OF LITERALS
-------------------------
String concatenation is the process of joining two or more strings together using operators. 

We can concate two sentences using + operator.We can only use it in single line.This method has been around since the early days of 
JavaScript.

we can also do it using \n but it is not decomandable.

eg: let userName = "Adithya";
    let myAge = 23;
    console.log("My name is " + userName + " myAge is " + myAge);

You can also use +=, where a += b is a shorthand for a = a + b.

let str = 'Hello';
str += ' ';
str += 'World';
str; // 'Hello World'

We can use Template literals for concatinate using ${varName} inside `backtick`.We can write in multiple lines using template literals
and is printed like it written in multilines.This is mostly used and recommended method.

Readability: Template literals improve the readability of your code by avoiding the clutter of multiple + operators.
Multiline Strings: Template literals allow for multiline strings without the need for escape sequences.

eg: let userName = "Adithya";
    let myAge = 23;
    console.log(`My name is ${useName} and i am ${myAge} years old.`);


OPERATORS IN JS
---------------
1) Arithmatic operators : +,-,*,/,%,**(Exponentiation/power),++(increment),--(decrement),-(unary operator gives negation of value).

Note: If we use + operator with 2 string then it will concatinate it.In other operator converts string to number if one operand is number 
      and perform operation.If both operands are sting then it will print NAN. In other programming language it will give error.

      We have to aware that if we do operation using any input value, we have to convert it into number because the input value is always 
      take it as string and the code will not going to show any error also. 

2) Relational Operators/comparison operator : >,<,>=,<=,!=,==(equality),===(strict equality: check both value as well as data type),
                                              !==(strict inequality) .
                         Returns a boolean value.

Note: If we compare with strings. first it will check the ascii value of first character, if both are same then move to another.
      If one operand is string and another is number it convert to number automatically then it will eveluated(inless we use ===).

      null == undefined => true & null === undefined => false.

      null is considered as 0 when it is comparing with numbers using (>,<,>=,<=) operators. but if we check (null == 0) then it
      will return false.undefined is always return false other than null.

3) Logical Operators - There are three logical operators in JavaScript: !(NOT),&&(AND),||(OR),??(Nullish Coalescing)
                        ! - It reverses the boolean result of the operand (or condition). 
                        && - If both operands are true then only it will returns true.
                        || - If any one of operand is true then it will returns true.
                        ?? - returns the right hand value if the left hand value is null or undefined.

Note: 

let a = 5;
let b;
console.log(a+b); - This will return NaN because compiler put variable b as undefined so 5 + undefined is NaN.

We can resolve this using falsy value 0 like:
console.log(a+(b||0)) - Here the last falsy value will be executed.



Automatic Type conversion using Operators 
-----------------------------------------
JavaScript automatically handles type conversion in many cases. Let's see how it behaves when using different types.

1) Adding(+) Strings and Numbers: When adding a string and a number, JavaScript treats the number as a string and concatenates them.

Eg:const x = 12;
const y = "3";
console.log(x + y); // Outputs: "123"

2) Other Operations with Strings and Numbers : For subtraction, multiplication, and division, JavaScript converts strings to numbers if
                                               possible.

Eg: 
console.log(x - y); // Outputs: 9
console.log(x * y); // Outputs: 36
console.log(x / y); // Outputs: 4

Mixing Types
When one operand is a number and the other is a string:

const x = 12;
const y = "3";
console.log(x + y); // Outputs: "123"
console.log(x - y); // Outputs: 9
console.log(x * y); // Outputs: 36
console.log(x / y); // Outputs: 4

3) Handling Non-Numeric Strings : If the string cannot be converted to a number, JavaScript returns NaN (Not-a-Number).

const x = "apple";
const y = "mango";
console.log(x + y); // Outputs: "applemango"
console.log(x - y); // Outputs: NaN
console.log(x * y); // Outputs: NaN
console.log(x / y); // Outputs: NaN

Note:
Best Practices
When dealing with user input or any data that might be in string format, it's essential to convert strings to numbers explicitly to 
avoid unexpected results.


Logical Operators with Truthy and Falsy Values
----------------------------------------------
Falsy Values - "" (empty string), 0 , null , undefined

In short Circuting all values are converted in to boolean values.

Note: If we converts this Falsy values to boolean value it will returns false. If there is space inside empty string then it will return 
      true.If you want to check wheather the value is truthy or falsy value convert the value to boolean like: boolean(value); 

let result = firstName||lastName||null||undefined - This is also called as SHORT CIRCUTING.

&&(AND) operator is not used for short circuting, we mostly use ||(OR) operator for short circuting.

||(OR) Operator with Falsy value
--------------------------------
|| operator returns the first truthy value it found outherwise it will return last value.

Example:

const firstName = "Bindu";
const lastName = "Adithya";

console.log(firstName||lastName); 
This will return 1st name because || operator converts the string to boolean value so it is true. If there is no name in firstName then
lastName will be returned.If there is more than two operands with no value then it execute last value.

&&(AND) Operator 
----------------
In && operator the first false value will be returned.If there is no False value then last truthy value will be executed/returned.

Example:

const firstName = "Adithya";
const lastName = "Bindu";

console.log(firstName||lastName); - In this case it will print Bindu because there is no flase value in this expression.

const firstName = "Adithya";
const lastName = "";

console.log(firstName||lastName); - Here it will print nothing because the lastName is executed here because lastName is a false value.


Nullish Coalescing Operator (New type of logical operator)
----------------------------------------------------------
Nullish Coalescing Operator: It is a new feature introduced in this ECMA proposal has now been adopted into the official JavaScript
Specification. This operator returns the right hand value if the left hand value is null or undefined. If not null or undefined then
it will return left hand value.

Before introducing Nullish Coalescing operator if statement and or(||) are used to set default value.
There are values in JavaScript like 0 and an empty string that are logically false by nature. These values may change the expected
behavior of the programs written in JavaScript. All the reoccurring problems led to the development of the Nullish Coalescing Operator.
The Nullish Coalescing Operator is defined by two adjacent question marks ?? and its use is as follows:

Syntax:
variable ?? default_value

Example:

let a = 0;

let result = a ?? "open"; - In this it will return 0.It will only return open when a is null or undefined. 


TYPE CONVERTION
---------------
Type conversion is an essential concept in JavaScript that allows us to convert one data type into another. This is particularly useful
in situations where data from an HTML input or text area needs to be manipulated as a different type.

Why type conversion is important in javascript because When taking data from an input field, it is usually in the form of a string, even
if the user enters a number. To perform numeric operations, you need to convert these strings to numbers. This is where type conversion
comes in handy.

1) to number : Number();
Note: A non numeric string (like "John") converts to NaN (Not a Number).

2) to sting : String()/var_name.toString();

How to convert string to numeric using +
----------------------------------------
var contact = "8839289289";
console.log(typeof contact); // Output: string

var convertedContact = +contact;
console.log(typeof convertedContact); //Output: number


3) to boolean : Boolean();

Conversion Rules in boolean conversion:

Any non-empty string is true.
An empty string is false.
The number 0 is false.
Any other number is true.


GETTING DATA USING NODE JS
--------------------------
Using readline-sync pakage we can get data from users.

Installing using node pakage manager(npm) : npm i/install readline-sync

step1: const readlineSync = require("readline-sync");
step2: readlineSync.question("Message/question"); - This will print the message as output.we can accept the data assigning to a variable.

eg:
const readlineSync = require("readline-sync");
const userName = readlineSync.question('May I know your name? ');
console.log(`Welcome, ${userName}!`);

Type this command in terminal to run this: node file_name.js


CONDITIONAL STATEMENTS
----------------------
Javascript conditional statements are:

1) if :
-------
if(condition){

}

2) if-else :
------------
if(condition){

}else{

}

3) nested-if:
-------------
if(condiiton){
    if(condition){

    }
}

4) if-else-if ladder:
---------------------
if(condition1){

}else if(condition2){

}else if(condition3){

}else{

}

5) switch :
------------
switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}

example:
const expr = 'Papayas';
switch (expr) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.');
    break;
  case 'Mangoes':
  case 'Papayas':
    console.log('Mangoes and papayas are $2.79 a pound.');
    // Expected output: "Mangoes and papayas are $2.79 a pound."
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}



TERNARY OPERATORS (Modern methord)
----------------------------------
Ternary operators offer a compact way to write conditional expressions in JavaScript. They can be used as a shorthand for if-else 
statements, making your code more concise and readable.

1) if-else: condition ? expressionIfTrue : expressionIfFalse

If the condition is true then expressionIfTrue statement is executed else expressionIfFalse statement will be executed.

Note: ternary operator is mostly used instead of if-else now.

2) if-else-if-ladder : condition1 ? true : condition2 ? true : condition3 : true : condition4 ? true : false;

    Example:
        let marks = 95;
        let result = (marks < 40) ? "Unsatisfactory": 
             (marks < 60) ? "Average":
             (marks < 80) ? "Good":"Excellent";

Note: This is not used widely because of readability issue. 

Advantages of Ternary Operators

Conciseness: Ternary operators make the code shorter.
Readability: For simple conditions, ternary operators can make the code easier to read.
Single-line expressions: Ternary operators are useful for inline assignments.

Drawbacks of Ternary Operators

Complexity: For multiple or nested conditions, ternary operators can become hard to read and maintain.
Debugging: Debugging nested ternary operators can be more challenging compared to if-else statements.



LOOPS IN JAVASCRIPT
-------------------
There are 2 Types of Loops ENTRY CONTROLED LOOP(For and While) and EXIT CONTROLED LOOP(Do-While).

1) While Loop : While loop is used when we don't know how many iterations to be done.

syntax: 

while (boolean condition)
{
   loop statements...
}

Example:

let i = 0;

while(i < 10){
    console.log(i);
    i++;
}

Note: we have to initialize outside the loop first and also incrementation/decrementation has to be done inside the loop. Otherwise 
      it will goes infinite.

2) For Loop : 

syntax:

for (initialization condition; testing condition; increment/decrement)
{
    statement(s)
}

Note: First initialization occurs then it checks the condition if it satisfies then it will execute the statements then increment/decrement
      initialized value again checks the condition if satisfies then again executes.This process will continues until the condition got
      unsatisfied.

3) Do-While Loop : Do-While loop is similar to the while loop with the only difference that it checks for the condition after executing
                   the statements once, and therefore is an example of an Exit Control Loop.

syntax: 

do
{
    statements..
}
while (condition);

Note: Note: we have to initialize outside the loop first and also incrementation/decrementation has to be done inside the loop. Otherwise
      it will get an infinite loop.


TRY CATCH BLOCK
----------------
We use try catch block in the places were we might know the error will happen/arise. We have to enclose that portion of code inside try
catch block. If there is any error occured for the code inside the try section then the catch will be executed else catch will be skipped.
If Javascript encounters any error it basically returns an error object and that error object can be passed as an parameter to the
catch block.

We use try catch block because to run program with out crashing/executing remaining code. The try catch block will manage it.
We use more in API calling etc...

syntax:

try{
    some line of codes.....
}catch(error){
    console.log("error Occured!!!");
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);
} finally {
    code inside this will executed wheather there is an error or not.
}

Note: we can know what type of error arised and what is the error message or issue by using methods like .name and .message
      we can also know where did the error occured with type and name using .stack method , this will give full details of error.

      Finally is optional, we only have to use it when it is needed.


FUNCTION IN JAVASCRIPT
----------------------
A function is a block of code designed to perform a particular task. You can think of functions as a way to encapsulate code that you
might want to reuse multiple times throughout your program. Instead of writing the same code repeatedly, you can call the function
whenever you need it.

Functions can accept inputs, known as parameters. When you call a function, you provide values for these parameters, known as arguments.

A function can accept multiple parameters separated by commas.

A function is a reusable piece of code that may take some input as parameters ,does some processing , and produces a certain output
based on the given inputs.

We can create functions in JavaScript using the keyword function. The basic syntax to create a function in JavaScript is shown below.

Note : If you call a function without passing all the required arguments, the missing arguments will be undefined.

Syntax:

function functionName(Parameter1, Parameter2, ..)
{
    // Function body
}

Note: We can call a function even before we have defined it. This is due to Hoisting in JavaScript. 

Note: Javascript does not throw an error if the number of arguments passed and number of parameters required do not match.
      There is an in-built arguments object in every function which holds all value passed to the function.

      The code written after the return value will not be executed.

Example:

function calcAddition(number1, number2) 
{ 
    return number1 + number2; 
}

console.log(calcAddition(2,3));


Anonymous Function
------------------
Anonymous Function is a function that does not have any name associated with it. Normally we use the function keyword before the
function name to define a function in JavaScript. However, for anonymous functions in JavaScript, we use only the function keyword
without the function name.

An anonymous function is not accessible after its initial creation, it can only be accessed by a variable it is stored in as a function
as a value. An anonymous function can also have multiple arguments, but only one expression.

Note: cannot be accessed before initialization.

Syntax: 

The syntax below illustrates the declaration of anonymous function using normal declaration:

function() {
    // Function Body
 }

We may also declare anonymous function using arrow function technique which is shown below:

( () => {
    // Function Body...
} )();

Example: 
var greet = function (platform) {
    console.log("Welcome to ", platform);
};
 
greet("GeeksforGeeks!");


Another use case of anonymous functions is to invoke the function immediately after initialization, this is also known as SELF EXECUTING
FUNCTION. This can be done by adding parenthesis we can immediately execute the anonymous function.

Example:
Way-1:

setTimeout(function () {
    console.log("Welcome to GeeksforGeeks!");
}, 2000);

Way-2:

(function () {
    console.log("Welcome to GeeksforGeeks!");
})();

As JavaScript supports Higher-Order Functions, we can also pass anonymous functions as parameters into another function.

Example 3: In this example, we pass an anonymous function as a callback function to the setTimeout() method. This executes this
 anonymous function 2000ms later.


setTimeout(function () {
    console.log("Welcome to GeeksforGeeks!");
}, 2000);

Output
Welcome to GeeksforGeeks!

Example 4: In this example, we have created a self-executing function.


(function () {
    console.log("Welcome to GeeksforGeeks!");
})();

Output
Welcome to GeeksforGeeks!


Arrow Function
--------------
ES6 introduced a new and shorter way of declaring an anonymous function, which is known as Arrow Functions. In an Arrow function,
everything remains the same, except here we don’t need the function keyword. Here, we define the function by a single parenthesis and
then ‘=>’ followed by the function body.

Note: Arrow function automatically returns a value without using return keyword in a single statement expression.

Example:
var greet = () =>
{
    console.log("Welcome to GeeksforGeeks!");
}

greet();

let greet = () => console.log("Welcome to GeeksforGeeks!");
greet();

const myFunction = param => { // function code }  
const myFunction = param => { return param*param }
                      or 
const myFunction = param => param*param

We can omit the {} parenthesis when there is only one statement and the JavaScript considers that statement as return value, also there
is no need to write parenthesis () when there is only one parameter. The arrow function cannot contain the line break between the (params)
and the arrow =>, Also there should not be any space between the = and > characters.  

limitation of Arrow Function:

No binding of this keyword: It cannot be used as a method because of not having a binding of this keyword. Arrow function contains the 
lexical this instead of their own. The value of this will be based upon the scope in which they are defined. So the arrow function is
defined in the window scope hence this will refer to the window object instead of the object in which the function has been written. 
There does not exist any property or method with ‘num’ hence undefined will be printed.

Eg:
var obj = {
  num: 10,
  myFunc: () => {console.log(this.num)}
}
  
obj.myFunc();

Output:
undefined

Explanation: The normal function contains this which refers to the object to which it belongs. Hence the function belongs to the obj 
object and property num exists inside it, so it will be printed successfully. 


What is Pure Function?
----------------------
1) Pure function accepts value as parameters.
2) Pure function returns a value.
3) Pure function will not e change the arguments value and its data type.




Dates in Javascript
-------------------
Syntax: new Date()

Example: New Date(year,month,day,hour,minute,seconds,ms);

New Date().getTime()
New Date().getMonth() / New Date().getFullYear()/ new Date().toISOString() and much more


Date Methods
------------
1) currentDt.getTime()
2) currentDt.getDay() - 0 : sunday, 1 : monday, 2: tuesday, 3: wednesday, 4: thursday, 5: friday, 6: saturday 
3) currentDt.getMonth()
4) currentDt.getFullYear()
5) currentDt.toDateString()
6) currentDt.toLocaleString()
 etc..


How to Convert Numbers to Date
------------------------------
var someDateTime = 166853609200;
var convertedDateTime = new Date(166853609200);
console.log(convertedDateTime);
console.log(convertedDateTime).getDate();


Math Library
------------
There are some predefined math function which we can use directly.

math.PI // 3.14
math.E // Euler's Number
math.SQRT2 // ^2 
math.SQRT1_2 // ^1/2
math.round(2.6) // 3
math.LN2 // Natural Logarithm of 2
math.ceil(4.4) // 5
math.floor(4.4) // 4
math.trunc(4.4) // 4
math.pow(8,2) // 64
math.sqrt(64) // 8

setInterval(()=>{
    console.log(math.random())
}, 1000);
//This will print random numbers 1000 times.



STRINGS
-------
In JavaScript, strings are considered objects when methods or properties are accessed/used on them. Although strings are primitive data
types, JavaScript automatically converts them to String objects when you try to use string methods. This process is called "autoboxing."

Here's an example:
let str = "Hello, World!";
console.log(str.length); // Outputs: 13

In this example, str is a primitive string, but when you access the .length property, JavaScript temporarily converts str into a String 
object so that it can access the property. After the property is accessed, it reverts back to a primitive value.

So, while strings in their basic form are primitive data types, JavaScript treats them as objects in certain contexts.


We can create a strings in 2 ways:

Strings can be created as primitives, from string literals, or as objects, using the String() constructor:

Using String literals:

const string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;

using string() constructor:

    const string4 = new String("A String object");

String primitives and string objects share many behaviors, but have other important differences and caveats.
data type of string declared using string primitive is String and string declared using constructor will be object.



String primitives and String objects also give different results when using eval(). Primitives passed to eval are treated as source
code; String objects are treated as all other objects are, by returning the object. For example:

const s1 = "2 + 2"; // creates a string primitive
const s2 = new String("2 + 2"); // creates a String object
console.log(eval(s1)); // returns the number 4
console.log(eval(s2)); // returns the string "2 + 2"

A String object can always be converted to its primitive counterpart with the valueOf() method.

    console.log(eval(s2.valueOf())); // returns the number 4

Note: All string methods return a new string. They don't modify the original string. Strings are immutable: Strings cannot be changed,
      only replaced.


String Iterations
-----------------
Whenever we are dealing with strings we need to iterate over them. There are basically two ways in which we can iterate over a string.
If you want value then use for of method. incase you need value as well as index then use normal for loop.

1) Firstly, we can simply use for(let char of message) to iterate through every character of the string instead of using normal for loop. 

Example
let message = "Hello Geeks";

//here char is a variable which takes the value of every letter in the message
for (let char of message){
	console.log(char);
}

2) The Second way in which we can iterate over a string is using index, ie. position of a particular character in the string. 

Example:
let message = "Hello Geeks";

console.log(message[0]) //print char at position 0
console.log(message[6]) //print char at position 6
console.log(message[5]) //print char at position 5

Note: Any special symbols or space is also a character in the string.

Therefore if we want to iterate over the entire string using indexes we make use of for loop as below.

let message = "Hello Geeks";

//here i takes the value of index for every character 
for (let i=0;i<message.length;i++){
	console.log(message[i]);
}

String Methods
--------------
String methods are built-in functions that perform various operations on strings. They can help you find the position of a character,
determine the length of a string, convert cases, and much more

1) .length : var_name.length will return the length of the value stored in the variable. Count starts from 1.

Example:
let message = "I am a mentor at GeeksforGeeks";
console.log(message.length); // Output: 30

Extracting String Characters
----------------------------
There are 4 methods for extracting string characters:

The at(position) Method
The charAt(position) Method
The charCodeAt(position) Method
Using property access [] like in arrays

2) .at() :  Returns character at given index of string. It allows the use of negative indexes while charAt() do not.

    Syntax : var_name.at(index)

    const name = "Adithya";
    let letter = name.at(2);
    console.log(letter); //Output: i

3) .charAt() : var_name.charAt(index) Returns character at given index of string.

syntax: character = myStr.charAt(index);

Arguments: The only argument to this function is the index in the string from where the single character is to be extracted. The range
of this index is between 0 and length - 1, including the limits. If no index is specified then the first character of the string is
returned as 0 is the default index used for this function. 

Return value : This function returns a single character located at the index specified as the argument to the function. If the index is
out of range/bounds, then this function returns an empty string. 

Note : If the index is out of bounds for the given string therefore the function returns "" an empty string. 

Example: 
function func() {

    // Original string
    var str = 'JavaScript is object oriented language';

    // Finding the character at given index 
    var value = str.charAt(0); 
    var value1 = str.charAt(4); 
    var value2 = str.charAt(50);
    console.log(value); 
    console.log(value1);
}
func();

Output:
J
S


4) str.charCodeAt() : The charCodeAt method returns the ASCII code of the character at a specified index.

    syntax: myStr.charCodeAt(index)

Arguments: The only argument to this method is the index of the character in the string whose Unicode is to be used. The range of the
index is from 0 to length - 1. 

Return value : This method returns the Unicode (ranging between 0 and 65535) of the character whose index is provided to the method as 
the argument. If the index provided is out of range this method returns NaN.

Note: If the index is out of bounds for the string, therefore this method returns the answer as NaN. 

Example:
function func() {
    var str = 'ephemeral';

    // Finding the code of the character at
    // given index 
    var value = str.charCodeAt(4);
    var value1 = str.chaCodeAt(20);
    console.log(value);    
}

func();

Output:
109
NaN

In this example the method charCodeAt() extracts the character from the string at index 4. Since this character is m, therefore this
method returns the Unicode sequence as 109. And value2 index is out of bound it return NaN.


Extracting String Parts
-----------------------
There are 3 methods for extracting a part of a string:

slice(start, end)
substring(start, end)
substr(start, length)

5) .slice() : slice() extracts a part of a string and returns the extracted part in a new string.

The method takes 2 parameters: start position, and end position (optional). If we omits second parameter,the method will slice out the 
rest of the string. -ve indexing is supported.

Syntax : var_name.slice(start position,end position);

Example: let text = "Apple, Banana, Kiwi";
         let part = text.slice(7, 13);
         //Output : Banana

         let text = "Apple, Banana, Kiwi";
         let part = text.slice(-12);
         //Output : Banana, Kiwi

6) .substring() : The substring() is an inbuilt function in JavaScript which is used to return the part of the given string from start
                  index to end index. Indexing start from zero (0).

                  substring() is similar to slice().The difference is that start and end values less than 0 are treated as 0 in
                  substring().

Syntax: string.substring(Startindex, Endindex)

Parameters: Here the Startindex and Endindex describes the part of the string to be taken as substring. Here the Endindex is optional. 

Return value: It returns a new string which is part of the given string. 

Note: Index always start with 0. If still we take index as negative, it will be considered as zero and index can't be in fraction
      if it is found so, it will be converted into its just lesser whole number. 

Example:
var string = "geeksforgeeks";
a = string.substring(-1)
b = string.substring(2.5)
c = string.substring(2.9)

// Printing new string which are
// the part of the given string
console.log(a);
console.log(b);
console.log(c);

Output
geeksforgeeks
eksforgeeks
eksforgeeks

7) .substr() : substr() is similar to slice(). The difference is that the second parameter specifies the length of the extracted part.

Parameters : start index position and length of extracted part. If you omit the second parameter, substr() will slice out the rest of 
             the string. -ve indexing is supported.

Example: let str = "Apple, Banana, Kiwi";
         let part = str.substr(7, 6);
         //Output : Banana

         If the first parameter is negative, the position counts from the end of the string.
         let str = "Apple, Banana, Kiwi";
         let part = str.substr(-4);
         //Output : Kiwi





8) .indexOf() : This function finds the index of the first occurrence of the argument string in the given string. The value returned 
                   is 0-based.

    Syntax: str.indexOf(searchValue , index)

Arguments: 
The first argument to the function searchValue is the string that is to be searched in the base string. The second argument to the
function index defines the starting index from where the searchValue is to be searched in the base string.

Return value: 
This function returns the index of the string (0-based) where the searchValue is found for the first time. If the searchValue cannot
be found in the string then the function returns -1.

Example:
function func() {

    // Original string
    var str = 'Departed Train';

    // Finding index of occurrence of 'Train'
    var index = str.indexOf('Train');
    console.log(index); 
}
func();

Output:
9

In this example, the function indexOf() finds the index of the string Train. Since the searchValue is not present in the string,
therefore this function returns -1 as the answer.


// JavaScript to illustrate indexOf() function
function func() {

    // Original string
    var str = 'Departed Train';

    // Finding index of occurrence of 'Train'
    var index = str.indexOf('train');
    console.log(index);  
}
func();

Output : -1

9) .lastIndexOf() : The lastIndexOf() method of String values searches this string and returns the index of the last occurrence of the
                    specified substring. It takes an optional starting position and returns the last occurrence of the specified 
                    substring at an index less than or equal to the specified number.

Syntax : lastIndexOf(searchString,position)

Example 1: 
const paragraph = "I think Ruth's dog is cuter than your dog!";
const searchTerm = 'dog';
console.log(
  `Index of the last ${searchTerm} is ${paragraph.lastIndexOf(searchTerm)}`,
);
// Expected output: "Index of the last "dog" is 38"

Example 2:
const anyString = "Brave, Brave New World";

console.log(anyString.indexOf("Brave")); // 0
console.log(anyString.lastIndexOf("Brave")); // 7


10) .search() :  search() method is used to search for a substring or pattern (using a regular expression) within a string. It returns
                 the index of the first match or -1 if no match is found.

Syntax: string.search(regex);

regex: Can be a string or a regular expression object.
The search is case-sensitive unless the i flag (for case-insensitive) is used in the regular expression.

Example 1: Search with a String
let str = "Hello world!";
let index = str.search("world");
console.log(index); // Output: 6

Example 2: Search with a Regular Expression
let str = "Hello world!";
let index = str.search(/world/i); // Case-insensitive search
console.log(index); // Output: 6

Difference between search() and indexOf():
search() allows the use of regular expressions, while indexOf() does not.
Both return the position of the first occurrence but have different usage depending on your needs (regular expressions vs. exact
 strings).


11) .includes() : In JavaScript, includes() method determines whether a string contains the given characters within it or not. This method
                 returns true if the string contains the characters, otherwise, it returns false. 
                 
                Syntax:  string.includes(searchvalue, start)

Parameters Used: 

search value: It is the string in which the search will take place.
start: This is the position from where the search will be processed 
(although this parameter is not necessary if this is not mentioned the search will begin from the start of the string).
Returns either a Boolean True indicating the presence or it returns a False indicating the absence.

Example:

var str = "Welcome to GeeksforGeeks.";
var check = str.includes("o",-2);
console.log(check);

Output: true

Note: The includes() method is case sensitive i.e, it will treat the Uppercase characters and Lowercase characters differently.
      
      If the computed index(starting index) i.e the position from which the search will begin is less than 0, the entire array will be
      searched. 

      If the second parameter is not defined, the search will take place from the starting index.




12) .toUpperCase() & .toLowerCase() : str.toUpperCase() method converts the entire string to Upper case/lowercase. This method does not 
                                     affect any of the special characters, digits, and the alphabets that are already in the upper case. 

Syntax:  str.toUpperCase() or str.toLowerCase()

Return value: 
This method returns a new string in which all the lower case letters are converted to upper case wisevera without effecting lowercase
letters.

Example:
function func() {
    var str = 'geeksforgeeks#@';
    var string = str.toUpperCase();
    console.log(string);
}
func();

Output: GEEKSFORGEEKS#@

In this example the method toUpperCase() converts all the lower case alphabets to their upper case equivalents without affecting the 
special characters and the digits. 



13) .concat() : concat() joins two or more strings, The concat() method can be used instead of the plus operator. These two lines do
                the same.

Syntax : var_name1.concat(var_name2);

Example : let text1 = "Hello";
          let text2 = "World";
          let text3 = text1.concat(" ", text2);
          //output : Hello World


14) .trim() : This method is used to remove the white spaces from both the ends of the given string.

Syntax:  str.trim()

Return value: This method returns a new string, without any of the leading or the trailing white spaces. 

Note: Trim is used to remove white spaces only from the start and end of a string and not from in-between. 

Example:
function func() {
    var str = "  Geeks for Geeks      ";
    var st = str.trim();
    console.log(st);
}
func();

Output
Geeks for Geeks


.trimLeft() / .trimRight() : method is used to remove the white spaces from the start/end of the given string. It does not affect
                                 the trailing white spaces.

Syntax:  str.trimLeft() / str.trimRight()

Return value: This method returns a new string, without any of the leading white spaces. 


15) .split() : JavaScript str.split() method is used to split the given string into an array of strings by separating it into substrings
              using a specified separator provided in the argument.

Syntax:  str.split(separator, limit)

separator: It is used to specify the character, or the regular expression, to use for splitting the string. If the separator is 
           unspecified then the entire string becomes one single array element. The same also happens when the separator is not present
           in the string. If the separator is an empty string (“”) then every character of the string is separated.

limit: Defines the upper limit on the number of splits to be found in the given string. If the string remains unchecked after the limit
       is reached then it is not reported in the array.

Return value: This function returns an array of strings that is formed after splitting the given string at each point where the 
              separator occurs.


Example 1: 

var str = 'It iS a 5r&e@@t Day.'
var array = str.split(" ");
print(array);
Output: In this example, the function split() creates an array of strings by splitting str wherever ” ” occurs.

[It,iS,a,5r&e@@t,Day.]

Example 2: 

var str = 'It iS a 5r&e@@t Day.'
var array = str.split(" ",2);
print(array);
Output: In this example, the function split() creates an array of strings by splitting str wherever ” ” occurs. The second argument 2
        limits the number of such splits to only 2.

[It,iS]



16) .padStart() : The padStart() method pads a string from the start. It pads a string with another string (multiple times) until it 
                  reaches a given length.

Syntax : var_name.padStart(No of pads, padding Number);

Examples:
Pad a string with "0" until it reaches the length 4:

let text = "5";
let padded = text.padStart(4,"0");
//Output : 00005
Pad a string with "x" until it reaches the length 4:

let text = "5";
let padded = text.padStart(4,"x");
//Output : xxxx5

Note: The padStart() & padEnd() method is a string method. To pad a number, convert the number to a string first using .toString() method.

17) .padEnd() : The padEnd() method pads a string from the end. Same as padStart().

Examples
let text = "5";
let padded = text.padEnd(4,"0");
//Output : 50000

18) .repeat() : The repeat() method returns a string with a number of copies of a string.The repeat() method returns a new string.
                The repeat() method does not change the original string.
Syntax: var_name.repeat(No of times/count);

Example : 
Create copies of a text:

let text = "Hello world!";
let result = text.repeat(2);
//Hello world!Hello world!

19) .replace() : *The replace() method replaces a specified value with another value in a string.
                 

Syntax : var_name.replace("replacing word","adding word");

Example
let text = "Going to visit google!";
let newText = text.replace("visit", "join");
//Output: Going to join google!

* By default, the replace() method replaces only the first match.

Example:
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace("Microsoft", "Google");
//output : Please visit Google and Microsoft

To replace all matches, use a regular expression with a /g flag (global match):

Example
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace(/Microsoft/g, "Google");
//Output: Please visit Google and Google

*By default, the replace() method is case sensitive. GOOGLE and google are considered as different.

To replace case insensitive, use a regular expression with an /i flag (case-insensitive):

Example
let text = "Please visit Microsoft!";
let newText = text.replace(/MICROSOFT/i, "Google!");
//Output: Please visit Google!

20) .replaceAll() : In 2021, JavaScript introduced the string method replaceAll(). Its same like .replace() but it replace all words
                    if there are multiple same word.

Example: let text = "I love cats. Cats are very easy to love. Cats are very popular."
         text = text.replaceAll("Cats","Dogs");
         text = text.replaceAll("cats","dogs");
         //Output: I love dogs.Dogs are very easy to love. Dogs are very popular.

The replaceAll() method allows you to specify a regular expression instead of a string to be replaced.

If the parameter is a regular expression, the global flag (g) must be set, otherwise a TypeError is thrown.

Example
text = text.replaceAll(/Cats/g,"Dogs");
text = text.replaceAll(/cats/g,"dogs");
//Output: I love dogs.Dogs are very easy to love. Dogs are very popular.

21) .startsWith() : The startsWith() method of String values determines whether this string begins with the characters of a specified 
                    string, returning true or false as appropriate.

Syntax : var_name.startsWith('searchString',position);

position means The start position at which searchString is expected to be found (the index of searchString's first character). 
Defaults to 0. position is optional.

Example : const str1 = 'Saturday night plans';

        console.log(str1.startsWith('Sat'));
        // Expected output: true

        console.log(str1.startsWith('Sat', 3));
        // Expected output: false

22) .normalize() : normalize() method is used to normalize a string into a specific Unicode normalization form. This can be helpful
                   when working with strings that include accented characters or other Unicode characters that may have multiple 
                   representations.

Syntax: string.normalize([form])

Parameters:
form (optional): The Unicode normalization form. The possible values are:
"NFC" (Canonical Decomposition followed by Canonical Composition, default)
"NFD" (Canonical Decomposition)
"NFKC" (Compatibility Decomposition followed by Canonical Composition)
"NFKD" (Compatibility Decomposition)


Example: 
const name1 = '\u0041\u006d\u00e9\u006c\u0069\u0065';
const name2 = '\u0041\u006d\u0065\u0301\u006c\u0069\u0065';

console.log(`${name1}, ${name2}`);
// Expected output: "Amélie, Amélie"
console.log(name1 === name2);
// Expected output: false
console.log(name1.length === name2.length);
// Expected output: false

const name1NFC = name1.normalize('NFC');
const name2NFC = name2.normalize('NFC');

console.log(`${name1NFC}, ${name2NFC}`);
// Expected output: "Amélie, Amélie"
console.log(name1NFC === name2NFC);
// Expected output: true
console.log(name1NFC.length === name2NFC.length);
// Expected output: true

Example 2 : 
let str = "\u00F1"; // 'ñ'
console.log(str.normalize("NFD")); 
// Output: 'ñ' (n followed by a combining tilde)

In this example, the character 'ñ' (U+00F1) is decomposed into two characters: 'n' (U+006E) and the combining tilde (U+0303).

Note: This method is particularly useful when comparing or searching strings where variations in encoding might lead to false mismatches.


23) .match() : The match() method in JavaScript is used to retrieve the result of matching a string against a regular expression. 
               It returns an array of matches or null if no match is found.

Syntax : string.match(regexp)

Parameters:
regexp: A regular expression object or a string that will be converted to a RegExp. If you pass a string, it will perform a basic search
(without pattern matching or special regular expression features).

Return Value:
If the regexp includes the global flag (g), the method returns an array of all matches.
If the regexp does not include the g flag, it returns an array with the first match and its capture groups, or null if no match is found.


Example 1: Without the g flag (returns only the first match):
let str = "The rain in Spain stays mainly in the plain";
let result = str.match(/ain/);
console.log(result);
// Output: ["ain", index: 5, input: "The rain in Spain stays mainly in the plain", groups: undefined]

Example 2: With the g flag (returns all matches):
let str = "The rain in Spain stays mainly in the plain";
let result = str.match(/ain/g);
console.log(result);
// Output: ["ain", "ain", "ain"]

Example 3: Using a string as the pattern (treated as a literal match):
let str = "Hello, world!";
let result = str.match("world");
console.log(result);
// Output: ["world", index: 7, input: "Hello, world!", groups: undefined]

Note: The match() method is often used with regular expressions for pattern matching in strings, making it useful for string searches, 
validation, and manipulation.

24) .matchAll() : The matchAll() method in JavaScript is used to return an iterator of all results matching a string against a regular 
                  expression, including capturing groups. It is similar to match(), but it returns an iterator, allowing you to iterate
                  through all matches when using regular expressions with the global (g) or sticky (y) flags.

Syntax : string.matchAll(regexp)

Parameters:
regexp: A regular expression object or a string that will be converted to a RegExp. The regexp must have the global (g) or sticky (y)
flag; otherwise, an error will be thrown.

Return Value:
Returns an iterator of RegExpMatchArray objects. You can convert this iterator to an array using the Array.from() method or a spread
operator (...).

Example 1: Iterating over all matches using a for...of loop:
let str = "The rain in Spain stays mainly in the plain";
let regexp = /ain/g;  // Notice the global 'g' flag
for (let match of str.matchAll(regexp)) {
  console.log(match);
}
// Output:
// ["ain", index: 5, input: "The rain in Spain stays mainly in the plain", groups: undefined]
// ["ain", index: 14, input: "The rain in Spain stays mainly in the plain", groups: undefined]
// ["ain", index: 28, input: "The rain in Spain stays mainly in the plain", groups: undefined]

Example 2: Converting the iterator to an array:
let str = "The rain in Spain stays mainly in the plain";
let regexp = /ain/g;
let matchesArray = Array.from(str.matchAll(regexp));
console.log(matchesArray);
// Output: 
// [
//   ["ain", index: 5, input: "The rain in Spain stays mainly in the plain", groups: undefined],
//   ["ain", index: 14, input: "The rain in Spain stays mainly in the plain", groups: undefined],
//   ["ain", index: 28, input: "The rain in Spain stays mainly in the plain", groups: undefined]
// ]

Example 3: Using capturing groups with matchAll():
let str = "I have 10 apples and 20 oranges.";
let regexp = /(\d+)\s(\w+)/g;  // Captures numbers and words
for (let match of str.matchAll(regexp)) {
  console.log(`Found ${match[2]}: ${match[1]}`);
}
// Output:
// Found apples: 10
// Found oranges: 20

Key Features:
Unlike match(), which returns an array of all matches or null, matchAll() provides access to capturing groups for all matches.
Works only with regular expressions with the g or y flags.
Can handle complex matches, especially when capturing groups are needed.
This method is useful when you need to extract all matches, including capturing group details, and need to efficiently iterate through
the results.


25) .endsWith() : The endsWith() method of String values determines whether a string ends with the characters of this string, returning
                  true or false as appropriate.

Syntax : String.endsWith(searchString, endPosition)

Example: 
const str1 = 'Cats are the best!';
console.log(str1.endsWith('best!'));
// Expected output: true

console.log(str1.endsWith('best', 17));
// Expected output: true

const str2 = 'Is this a question?';

console.log(str2.endsWith('question'));
// Expected output: false


26) .codePointAt() : The codePointAt() method in JavaScript is used to return the Unicode code point value of a character at a specified
                     position in a string. This method can handle characters that are represented by two code units (known as surrogate
                     pairs), such as certain emoji or rare Unicode characters.

Syntax: string.codePointAt(index)

Parameters:
index: The position of the character in the string (0-based index).

Return Value:
Returns a number representing the Unicode code point of the character at the specified index. If there is no character at that index,
it returns undefined.

Example 1: Basic usage with a single character:
let str = "ABC";
console.log(str.codePointAt(0));  // Output: 65 (Unicode of 'A')
console.log(str.codePointAt(1));  // Output: 66 (Unicode of 'B')
console.log(str.codePointAt(2));  // Output: 67 (Unicode of 'C')

Example 2: Using codePointAt() with surrogate pairs (e.g., emoji):
let str = "😎";
console.log(str.codePointAt(0));  // Output: 128526 (Unicode code point for the sunglasses emoji)

Example 3: Handling characters with surrogate pairs:
For characters like emoji, which are represented by two code units (surrogate pairs), charCodeAt() won't work properly. However, 
codePointAt() handles these cases.

let str = "👍";
console.log(str.charCodeAt(0));   // Output: 55357 (the first part of the surrogate pair)
console.log(str.charCodeAt(1));   // Output: 56397 (the second part of the surrogate pair)
console.log(str.codePointAt(0));  // Output: 128077 (correct Unicode code point for the thumbs-up emoji)

Example 4: Dealing with undefined for invalid index:
let str = "Hello";
console.log(str.codePointAt(10)); // Output: undefined (index out of bounds)

Use Cases:
Extracting the full Unicode code point of characters that are represented by surrogate pairs.
Handling special characters (such as emoji) correctly when working with strings.
The codePointAt() method is especially useful when dealing with multi-byte characters (like emoji or characters outside the Basic
Multilingual Plane) in Unicode text.

27) .valueOf() : The valueOf() method in JavaScript is used to return the primitive value of a string object. While it is automatically
                 called in many contexts, you can also invoke it explicitly if needed.

Syntax: string.valueOf()

parameter : none

Return Value: Returns the primitive value (a string) of the specified string object.

Example : const stringObj = new String('foo');

console.log(stringObj);
// Expected output: String { "foo" }

console.log(stringObj.valueOf());
// Expected output: "foo"

28) .wellFormed() : The toWellFormed() method in JavaScript is used to return a well-formed version of a string, ensuring that any lone
                    surrogates are replaced with the Unicode replacement character (�). This is helpful when working with strings that
                    may have been corrupted or contain invalid Unicode characters.

Syntax: string.toWellFormed()

Parameter : none

Return Value: Returns a new string that is well-formed, with lone surrogates replaced by the Unicode replacement character.

Background:
In Unicode, some characters are represented by two code units (surrogate pairs). If one of the surrogate pairs is missing, the character
is considered a "lone surrogate," which is invalid in a well-formed string.

toWellFormed() replaces these invalid lone surrogates with the replacement character (�).

Example 1: Handling lone surrogates:
let str = "Hello \uD800 World";  // \uD800 is a lone high surrogate
console.log(str);               // Output: "Hello � World" (depending on how your console displays it)
console.log(str.toWellFormed()); // Output: "Hello � World"

Example 2: Well-formed string remains unchanged:
let str = "Hello 😊 World";      // Valid Unicode string
console.log(str.toWellFormed()); // Output: "Hello 😊 World" (No change)

Use Case:
Data Sanitization: When processing or displaying text that may come from external or unreliable sources (such as user input or external
APIs), toWellFormed() ensures that any invalid surrogate pairs are handled gracefully, preventing potential errors or rendering issues.

Key Points:
It replaces invalid surrogate pairs with the replacement character.
It is useful for ensuring text is well-formed before processing or displaying it.

29) .toLocaleLowerCase() & .toLocaleUpperCase() : toLocaleLowerCase()  method used to convert a string to lowercase, taking into account the
                                                locale-specific case mappings. toLocaleUpperCase is viseversa.
                        
Syntax: string.toLocaleLowerCase([locales[, options]])





ARRAYS IN JAVASCRIPT
--------------------
In JavaScript, the array is a single variable that is used to store different elements. It is often used when we want to store a list of
elements and access them by a single variable. Unlike most languages where the array is a reference to the multiple variables, in
JavaScript array is a single variable that stores multiple elements.

An array in JavaScript can hold different elements that can store Numbers, Strings, and Boolean in a single array.

We can access Array elements using indexes starting from 0.

Declaration of Array
--------------------
There are basically two ways to declare an array.

var House = [ ]; // Method 1
var House = new Array(); // constructor Method 2

Note: But generally method 1 is preferred over method 2. Let us understand the reason for this.


Example: Initialization of an Array according to method 1.

// Initializing while declaring
var house = ["1BHK", "2BHK", "3BHK", "4BHK"];


Example: Initialization of an Array according to method 2.

// Initializing while declaring
// Creates an array having elements 10, 20, 30, 40, 50
var house = new Array(10, 20, 30, 40, 50);

// Creates an array of 5 undefined elements
var house1 = new Array(5);

// Creates an array with element 1BHK
var home = new Array("1BHK");

As shown in above example the house contains 5 elements i.e. (10 , 20, 30, 40, 50) while house1 contains 5 undefined elements instead of
having a single element 5. Hence, while working with numbers this method is generally not preferred but it works fine with Strings and
Boolean as shown in the example above home contains a single element 1BHK.

Iterations in Javascript
------------------------
Arrays in Javascripts, are single variables used to store different kind of elements.
For example, a simple array accesses may look something like this: 

array = [ 'geeks', '4', 'geeks' ];
 
// Accessing array elements one by one
console.log(array[0]);
console.log(array[1]);
console.log(array[2]);


There are multiple ways one can iterate over an array in JavaScript.

1) Using for loop:
array = [ 1, 2, 3, 4, 5, 6 ];
for (index = 0; index < array.length-1; index++) {
    console.log(array[index]);
}

2) Using for - let of:
array = [1,2,3,4,5,6];
for (let num of array){
    console.log(num);
}

//Output: 1,2,3,4,5,6

3) for in : This will give index.
array = [1,2,3,4,5,6];
for (let num in array){
    console.log(num);
}

//Output: 0 1 2 3 4 5.

You can also get elements in array using let in:
array = [1,2,3,4,5,6];
for (let num in array){
    console.log(array[num]);
}

//Output: 1 2 3 4 5 6.


4) Using while loop:
index = 0;
array = [ 1, 2, 3, 4, 5, 6 ];
 
while (index < array.length) {
    console.log(array[index]);
    index++;
}

5) using forEach method : The forEach method calls the provided function once for every array element in the order. forEach expect a 
                          function as argument.
index = 0;
array = [ 1, 2, 3, 4, 5, 6 ];
 
array.forEach(myFunction);
function myFunction(item, index)
{
    console.log(item);
}

6) Using every method : The every() method checks if all elements in an array pass a test (provided as a function). 
index = 0;
array = [ 1, 2, 3, 4, 5, 6 ];
 
const under_five = x => x < 5;
 
if (array.every(under_five)) {
    console.log('All are less than 5');
}
else {
    console.log('At least one element is not less than 5');
}

7) Using map : A map applies a function over every element and then returns the new array. 
index = 0;
array = [ 1, 2, 3, 4, 5, 6 ];
 
square = x => Math.pow(x, 2);
squares = array.map(square);
console.log(array);
console.log(squares);

8) Using Filter : It is used to filter values from an array and return the new filtered array.
array = [ 1, 2, 3, 4, 5, 6 ];
 
even = x => x%2 === 0;
evens = array.filter(even);
console.log(array);
console.log(evens);

9) Using Reduce : It is used to reduce the array into one single value using some functional logic.
array = [ 1, 2, 3, 4, 5, 6 ];
 
const helperSum = (acc,curr) => acc+curr
sum = array.reduce(helperSum, 0);
 
console.log(array)
console.log(sum);

10) Using Some : It is used to check whether some array values passes a test.
array = [ 1, 2, 3, 4, 5, 6 ];
 
const lessthanFourCheck = (element) => element < 4 ;
const lessthanFour = array.some(lessthanFourCheck)
 
 
console.log(array);
if(lessthanFour){
    console.log("At least one element is less than 4" )
}else{
    console.log("All elements are greater than 4 ")
}




Array Methods In Javascript
---------------------------

1) .toString() : The JavaScript method toString() converts an array to a string of (comma separated) array values.

Syntax : array.toString();

Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let result = fruits.toString();
//Output: Banana,Orange,Apple,Mango

2) .join() : The arr.join() method is used to join the elements of an array into a string. The elements of the string will be separated
              by a specified separator and its default value is a comma(, ).

Syntax: array.join("separator");

Parameters: This method accepts single parameter as mentioned above and described below:

separator: It is Optional i.e, it can be either used as parameter or not. Its default value is comma(, ).

Return Value: It returns the string which contain the collection of array's elements.

Example 1: In this example the function join() joins together the elements of the array into a string using ‘|’.
var a = [1, 2, 3, 4, 5, 6];
print(a.join('|'));

Output:
1|2|3|4|5|6

Example 2: In this example the function join() joins together the elements of the array into a string using ‘, ‘ since it is the default value.
var a = [1, 2, 3, 4, 5, 6];
print(a.join()); 

Output:
1, 2, 3, 4, 5, 6

Example 3: In this example the function join() joins together the elements of the array into a string using ‘ ‘ (empty string).
var a = [1, 2, 3, 4, 5, 6];
print(a.join(''));

Output:
123456



3) .sort() Method: The arr.sort() method is used to sort the array in place in a given order according to the compare() function. If the
               method is omitted then the array is sorted in ascending order. In sort method first the compare element is converted to
               number then it will compare with other operand using uft table.

Syntax: arr.sort(compareFunction)

Parameters: This method accepts a single parameter as mentioned above and described below:

compareFunction: This parameter is used to sort the elements according to different attributes and in a different order.

compareFunction(a,b) < 0
compareFunction(a,b) > 0
compareFunction(a,b) = 0
Return value: This method returns the reference of the sorted original array.

Example 1: In this example, the sort() method arranges the elements of the array in ascending order.

var arr = [2, 5, 8, 1, 4]
console.log(arr.sort());
console.log(arr);
Output:

1,2,4,5,8
1,2,4,5,8

Example 2: In this example, we use the sort() method on the array of numbers & observe some unexpected behavior.

let numbers = [20,5.2,-120,100,30,0]
console.log(numbers.sort())
Output:

-120,0,100,20,30,5.2
Our output should be -120, 0, 5.2, 20, 30, 100 but it’s not so, why? Because as we apply the direct sort() method, it would process
accordingly: 100 would be placed before 20, as ‘2’ is larger than ‘1’, and similarly in the case of 30 & 5.2,  as ‘5’ is larger 
than ‘3’ thus, 30 would be placed before 5.2. We can resolve this unexpected error by using the sort() method for numerics using the 
following compare function: 

let numbers = [20,5.2,-120,100,30,0];

/* Logic: 
   20 - (5.2) = +ve => 5.2 would be placed before 20,
   20 - (-120) = +ve => -120 would be placed before 20,
   20 - (100) = -ve => 100 would be placed after 20,
   20 - (30) = -ve => 30 would be placed after 20,
   20 - (0) = +ve => 0 would be placed before 20,
   Similarly for every element, we check and place them accordingly in iterations.
*/
function compare(a,b){
    return a-b;
}
console.log(numbers.sort(compare));
Output:

-120,0,5.2,20,30,100

Time Complexity: The time complexity of the sort() method varies & depends on implementation.
For example, in the Firefox web browser, it uses the merge sort implementation which gives time complexity as O(nlog n). Whereas, in
Google Chrome web browser, it uses the Timsort implementation (a hybrid of merge sort and insertion sort), gives time complexity is
O(nlogn).


4) .entries() : The entries() method in JavaScript is used to return a new Array Iterator object that contains key/value pairs for each
                 index in the array.

Syntax: array.entries()

Example:
const arr = ['a', 'b', 'c'];

const iterator = arr.entries();

for (let entry of iterator) {
  console.log(entry);
}

Output:
[0, 'a']
[1, 'b']
[2, 'c']
In this example, the entries() method returns an iterator with key-value pairs where the key is the index and the value is the element
from the array.

Use Cases: Useful when you need both the index and the value while looping over an array.


5) .every() : The every() method in JavaScript checks if all elements in an array pass a test (provided as a function). It returns
                boolean values, either true or false.

Syntax: every(callbackFn) / every(callbackFn, thisArg)

Example:
const isBelowThreshold = (currentValue) => currentValue < 40;
const array1 = [1, 30, 39, 29, 10, 13];
console.log(array1.every(isBelowThreshold));
// Expected output: true

Example2:
const numbers = [2, 4, 6, 8];
const isEven = numbers.every(num => num % 2 === 0);
console.log(isEven); // Output: true

6) .fill() : The fill() method of Array instances changes all elements within a range of indices in an array to a static value. It
              returns the modified array.

Syntax: fill(value) / fill(value, start) / fill(value, start, end)

Example:
const array1 = [1, 2, 3, 4];

// Fill with 0 from position 2 until position 4
console.log(array1.fill(0, 2, 4));
// Expected output: Array [1, 2, 0, 0]

// Fill with 5 from position 1
console.log(array1.fill(5, 1));
// Expected output: Array [1, 5, 5, 5]

console.log(array1.fill(6));
// Expected output: Array [6, 6, 6, 6]

7) .filter() : The filter() method of Array instances creates a shallow copy of a portion of a given array, filtered down to just the
                elements from the given array that pass the test implemented by the provided function. 

Syntax: filter(callbackFn, thisArg);

Example:
const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter((word) => word.length > 6);
console.log(result);
// Expected output: Array ["exuberant", "destruction", "present"]

8) .find() : The find() method of Array instances returns the first element in the provided array that satisfies the provided testing 
              function. If no values satisfy the testing function, undefined is returned.
              
Syntax: find(callbackFn, thisArg)

Example:
const array1 = [5, 12, 8, 130, 44];
const found = array1.find((element) => element > 10);
console.log(found);
// Expected output: 12

9) .findIndex() : The findIndex() method of Array instances returns the index of the first element in an array that satisfies the
                   provided testing function. If no elements satisfy the testing function, -1 is returned.
                   similar to find. If you need value use find() or if you need index of first value satisfies condition use findIndex().

Syntax: findIndex(callbackFn, thisArg)

Example:
const array1 = [5, 12, 8, 130, 44];
const isLargeNumber = (element) => element > 13;
console.log(array1.findIndex(isLargeNumber));
// Expected output: 3

10) .findLast() : The findLast() method of Array instances iterates the array in reverse order and returns the value of the first 
                  element that satisfies the provided testing function. If no elements satisfy the testing function, undefined is
                  returned.

Syntax : findLast(callbackFn, thisArg)

Example:
const array1 = [5, 12, 50, 130, 44];
const found = array1.findLast((element) => element > 45);
console.log(found);
// Expected output: 130

11) .findLastIndex() : The findLastIndex() method of Array instances iterates the array in reverse order and returns the index of the
                        first element that satisfies the provided testing function. If no elements satisfy the testing function, -1 is
                        returned.

Syntax: findLastIndex(callbackFn, thisArg

Example:
const array1 = [5, 12, 50, 130, 44];
const isLargeNumber = (element) => element > 45;
console.log(array1.findLastIndex(isLargeNumber));
// Expected output: 3
// Index of element with value: 130

12) .some() : The some() method of Array instances tests whether at least one element in the array passes the test implemented by the
             provided function. It returns true if, in the array, it finds an element for which the provided function returns true; 
             otherwise it returns false. It doesn't modify the array.

Syntax: some(callbackFn) / some(callbackFn, thisArg)

Example:
const array = [1, 2, 3, 4, 5];

// Checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// Expected output: true

Use Cases to find an element:
----------------------------
*If you need the index of the found element in the array, use findIndex().
*If you need to find the index of a value, use indexOf(). (It's similar to findIndex(), but checks each element for equality with the
    value instead of using a testing function.)
*If you need to find if a value exists in an array, use includes(). Again, it checks each element for equality with the value instead of
    using a testing function.
*If you need to find if any element satisfies the provided testing function, use some().
*If you need to find all elements that satisfy the provided testing function, use filter().


13) .flat() : The flat() method of Array instances creates a new array with all sub-array elements concatenated into it recursively up
              to the specified depth.

Syntax: flat() / flat(depth)

Example:
const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat());
// expected output: Array [0, 1, 2, 3, 4]

const arr2 = [0, 1, [2, [3, [4, 5]]]];
console.log(arr2.flat());
// expected output: Array [0, 1, 2, Array [3, Array [4, 5]]]

console.log(arr2.flat(2));
// expected output: Array [0, 1, 2, 3, Array [4, 5]]

console.log(arr2.flat(Infinity));
// expected output: Array [0, 1, 2, 3, 4, 5]

14) .flatMap() : The flatMap() method of Array instances returns a new array formed by applying a given callback function to each element
                 of the array, and then flattening the result by one level. It is identical to a map() followed by a flat() of depth 1 
                 (arr.map(...args).flat()), but slightly more efficient than calling those two methods separately.

Syntax: flatMap(callbackFn, thisArg)

Example:
const arr1 = [1, 2, 1];
const result = arr1.flatMap((num) => (num === 2 ? [2, 2] : 1));
console.log(result);
// Expected output: Array [1, 2, 2, 1]

15) .forEach() : The forEach() method of Array instances executes a provided function once for each array element.

Syntax: forEach(callbackFn, thisArg)

Example:
const array1 = ['a', 'b', 'c'];

array1.forEach((element) => console.log(element));

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"



16) .map() : The map() method of Array instances creates a new array populated with the results of calling a provided function on every
             element in the calling array.

Syntax: map(callbackFn) / map(callbackFn, thisArg)

Example:
const array1 = [1, 4, 9, 16];

// Pass a function to map
const map1 = array1.map((x) => x * 2);

console.log(map1);
// Expected output: Array [2, 8, 18, 32]


17) .reduce() : The reduce() method of Array instances executes a user-supplied "reducer" callback function on each element of the array,
                in order, passing in the return value from the calculation on the preceding element. The final result of running the 
                reducer across all elements of the array is a single value.

The first time that the callback is run there is no "return value of the previous calculation". If supplied, an initial value may be used
in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 
instead of index 0).

Syntax: reduce(callbackFn) / reduce(callbackFn, initialValue)

Example:
const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  initialValue,
);

console.log(sumWithInitial);
// Expected output: 10

18) .reduceRight() : The reduceRight() method of Array instances applies a function against an accumulator and each value of the array
                     (from right-to-left) to reduce it to a single value.

Syntax: reduceRight(callbackFn) / reduceRight(callbackFn, initialValue)

Example:
const array1 = [
  [0, 1],
  [2, 3],
  [4, 5],
];

const result = array1.reduceRight((accumulator, currentValue) =>
  accumulator.concat(currentValue),
);

console.log(result);
// Expected output: Array [4, 5, 2, 3, 0, 1]

19) .reverse() : The reverse() method of Array instances reverses an array in place and returns the reference to the same array, the 
                 first array element now becoming the last, and the last array element becoming the first. In other words, elements
                 order in the array will be turned towards the direction opposite to that previously stated.

                 To reverse the elements in an array without mutating the original array, use toReversed().

Syntax: reverse()

Example:
const array1 = ['one', 'two', 'three'];
console.log('array1:', array1);
// Expected output: "array1:" Array ["one", "two", "three"]

const reversed = array1.reverse();
console.log('reversed:', reversed);
// Expected output: "reversed:" Array ["three", "two", "one"]

// Careful: reverse is destructive -- it changes the original array.
console.log('array1:', array1);
// Expected output: "array1:" Array ["three", "two", "one"]




20) .splice() : The splice() method of Array instances changes the contents of an array by removing or replacing existing elements 
                and/or adding new elements in place.
                
                To create a new array with a segment removed and/or replaced without mutating the original array, use toSpliced().
                To access part of an array without modifying it, see slice().

Syntax:
splice(start)
splice(start, deleteCount)
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2)
splice(start, deleteCount, item1, item2, /* …, */ itemN)


Example:
const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// Inserts at index 1
console.log(months);
// Expected output: Array ["Jan", "Feb", "March", "April", "June"]

months.splice(4, 1, 'May');
// Replaces 1 element at index 4
console.log(months);
// Expected output: Array ["Jan", "Feb", "March", "April", "May"]


21) .keys() : The keys() method of Array instances returns a new array iterator object that contains the keys for each index in the array.

Syntax: keys()

Example:
const array1 = ['a', 'b', 'c'];
const iterator = array1.keys();

for (const key of iterator) {
  console.log(key);
}

// Expected output: 0
// Expected output: 1
// Expected output: 2

22) .values() : The values() method of Array instances returns a new array iterator object that iterates the value of each item in the
                array.

Syntax: values()

Example: 
const array1 = ['a', 'b', 'c'];
const iterator = array1.values();

for (const value of iterator) {
  console.log(value);
}

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"

23) .with() : The with() method of Array instances is the copying version of using the bracket notation to change the value of a given 
              index. It returns a new array with the element at the given index replaced with the given value.

Syntax: arrayInstance.with(index, value)

Example:
const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6)); // [1, 2, 6, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5]

const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6).map((x) => x ** 2)); // [1, 4, 36, 16, 25]



Adding And Removing Elements in Array
--------------------------------------

24) .push() : The arr.push() method is used to push one or more values into the array. This method changes the length of the array by the
              number of elements added to the array. The elements are added to the end of the array.

Syntax: arr.push(element1, elements2 ....., elementN)

Parameters: This method contains as many numbers of parameters as the number of elements to be inserted into the array. 

Return value: This method returns the new length of the array after inserting the arguments into the array. 

Example:
var arr = [34, 234, 567, 4];
console.log(arr.push(23,45,56));
console.log(arr);

Output:
7
34,234,567,4,23,45,56


25) .pop() : The arr.pop() method is used to remove the last element of the array and also returns the removed element. This function
             decreases the length of the array.

Syntax: arr.pop()

Parameters: This method does not accept any parameter.

Returns: This method returns the removed element array. If the array is empty, then this function returns undefined.

Example:
var arr = [34, 234, 567, 4];
var popped = arr.pop();
console.log(popped);
console.log(arr);

Output:
4
34,234,567

Example-2:
In this example, the function pop() tries to extract the last element of the array but since the array is empty therefore it returns
undefined as the answer.

var arr = [];
var popped = arr.pop();
print(popped);

Output:
undefined


26) .shift() : The shift() method removes the first element in array and "shifts" all other elements to a lower index.
               The shift() method returns the value that was "shifted out":

Syntax : array.shift();

Example:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.shift();

27) .unshift() : The unshift() method adds a new element at the beginning of the array.

Syntax: array.unshift("new element");

Example:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.unshift("Lemon");
//Output: ["Lemon","Banana", "Orange", "Apple", "Mango"];

Note: we can also add element using index like
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits[0] = "Kiwi";
//Output: ["Kiwi","Banana", "Orange", "Apple", "Mango"]


28) delete array[] : delete method will also remove element from array but it leaves undefined holes in the array.
                Use pop() or shift() instead.

Syntax: delete array[index];

Example:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
delete fruits[0];




29) .copyWithin() : The copyWithin() method copies array elements to another position in an array

Examples:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.copyWithin(2, 0);
//Output: ["Banana", "Orange","Banana", "Orange"];

Example2:
const fruits = ["Banana", "Orange", "Apple", "Mango", "Kiwi","Pappaya"];
fruits.copyWithin(2, 0, 2);
//Output: ["Banana", "Orange", "Banana", "Orange", "Kiwi","Pappaya"]

Note:The copyWithin() method overwrites the existing values.

The copyWithin() method does not add items to the array.

The copyWithin() method does not change the length of the array.


COMMON METHODS
--------------
30) .length() : The length property returns the length (size) of an array.

Syntax : array.length;

Example:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let size = fruits.length;

31) .at() : 

Syntax: array.at(index);

Example: 
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits.at(2);
//Output: Apple

we can also access element by:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits[2];

Note:
Many languages allows negative bracket indexing like [-1] to access elements from the end of an object / array / string.

This is not possible in JavaScript, because [] is used for accessing both arrays and objects. obj[-1] refers to the value of key -1, not to the last property of the object.

The at() method was introduced in ES2022 to solve this problem.


32) .concat() : The concat() method creates a new array by merging (concatenating) existing arrays.The concat() method can also take
                strings as arguments.

Syntax: arr1.concat(arr2,"string",arr3,..);

Example:
const myGirls = ["Cecilie", "Lone"];
const myBoys = ["Emil", "Tobias", "Linus"];

const myChildren = myGirls.concat(myBoys);
//Output: ["Cecilie", "Lone","Emil", "Tobias", "Linus"];

Example2:
const arr1 = ["Emil", "Tobias", "Linus"];
const myChildren = arr1.concat("Peter"); 
//Output: ["Emil", "Tobias", "Linus","Peter"];

Note: The concat() method does not change the existing arrays. It always returns a new array.

The concat() method can take any number of array arguments.



33) slice() Method : The arr. slice() method returns a new array containing a portion of the array on which it is implemented. The 
                     original remains unchanged.

Syntax: arr.slice(beginIndex, endIndex)

Parameters: This method accepts two parameters as mentioned above and described below:

begin: This parameter defines the starting index from where the portion is to be extracted. If this argument is missing then the method
takes begin as 0 as it is the default start value.

end: This parameter is the index up to which the portion is to be extracted (excluding the end index). If this argument is not defined 
then the array till the end is extracted as it is the default end value If the end value is greater than the length of the array, then
the end value changes to the length of the array.

Return value: This method returns a new array containing some portion of the original array. 

Example 1: In this example, the slice() method extracts the array from the given array starting from index 2 and including all the
           elements less than the index 4.

var arr = [23,56,87,32,75,13];
var new_arr = arr.slice(2,4);
console.log(arr);
console.log(new_arr);
Output:

[23,56,87,32,75,13]
[87,32]

Example 2: In this example, the slice() method extracts the array starting from index 2 till the end of the array and returns it as
           the answer.

var arr = [23,56,87,32,75,13];
var new_arr = arr.slice(2);
console.log(arr);
document.write(new_arr);
Output:

[23,56,87,32,75,13]
[87,32,75,13]

Example 3: In this example, the slice() method extracts the entire array from the given string and returns it as the answer since no
           arguments were passed to it.

var arr = [23,56,87,32,75,13];
var new_arr = arr.slice();
console.log(arr);
console.log(new_arr);
Output:

[23,56,87,32,75,13]
[23,56,87,32,75,13]


34) includes() Method: The array.includes() method is used to know either a particular element is present in the array or not and 
                       accordingly, it returns true or false i.e, if the element is present, then it returns true otherwise false.

Syntax: array.includes(searchElement, start)

Parameter: This method accepts two parameters as mentioned above and described below:

searchElement: This parameter holds the element which will be searched.
start: This parameter is optional and it holds the starting point of the array, where to begin the search the default value is 0.

Return Value: It returns a Boolean value i.e, either True or False.

Example: In this example the method will searched for the element 2 in that array.
Input : [1, 2, 3, 4, 5].includes(2);
Output: true


35) .indexOf() : The indexOf() method of Array instances returns the first index at which a given element can be found in the array, 
                 or -1 if it is not present.

Syntax: indexOf(searchElement, fromIndex)

Example:
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// Expected output: 1

// Start from index 2
console.log(beasts.indexOf('bison', 2));
// Expected output: 4

console.log(beasts.indexOf('giraffe'));
// Expected output: -1

36) .lastIndexOf() : The lastIndexOf() method of Array instances returns the last index at which a given element can be found in the 
                     array, or -1 if it is not present. The array is searched backwards, starting at fromIndex.

Syntax: lastIndexOf(searchElement) / lastIndexOf(searchElement, fromIndex)


Example:
const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

console.log(animals.lastIndexOf('Dodo'));
// Expected output: 3

console.log(animals.lastIndexOf('Tiger'));
// Expected output: 1



SPREAD OPERATOR
---------------
Spread Opertor is used to spread the Array values/items individually.

Spread operator allows an iterable to expand in places where 0+ arguments are expected. It is mostly used in the variable array where
there is more than one value expected. It allows us the privilege to obtain a list of parameters from an array. Syntax of Spread operator
is same as Rest parameter but it works completely opposite of it.

Syntax:

var variablename1 = [...value];  : This will spread all values stored in variable value in varibalename1.

Example:
let arr = [1,2,3];
let arr2 = [4,5];
  
arr = [...arr,...arr2];
console.log(arr); 

Output:
[ 1, 2, 3, 4, 5 ]


DESTRUCTURING IN JAVASCRIPT
---------------------------
The Destructuring assignment is the important technique introduced in ECMAScript 2015 (ES6) version of JavaScript that provides a
shorthand syntax to extract or unpack array elements or properties of an object into distinct variables using a single line of code.
In other words, this assignment helps us to segregate data of any iterable as well as non-iterable object and then helps us to use that
segregated data individually on need or demand. It makes the code shorter and more readable. 

In general way implementation of the extraction of the array is as shown below: 

Syntax:

Array destructuring:
var x, y;
[x, y] = [10, 20];
console.log(x); // 10
console.log(y); // 20

or

[x, y, ...restof] = [10, 20, 30, 40, 50];
console.log(x); // 10
console.log(y); // 20
console.log(restof); // [30, 40, 50]

Note: This ...restof is called as rest operator looks similer to spread operator but its working is different. Here this will comibine 
        existing values in restof variable.

Object destructuring:
({ x, y} = { x: 10, y: 20 });
console.log(x); // 10
console.log(y); // 20

or

({x, y, ...restof} = {x: 10, y: 20, m: 30, n: 40});
console.log(x); // 10
console.log(y); // 20
console.log(restof); // {m: 30, n: 40}


Array Destructuring
-------------------
Example 2: The array elements can be skipped as well using a comma separator. A single comma can be used to skip a single array element.
One key difference between the spread operator and array destructuring is that the spread operator unpacks all array elements into a 
comma-separated list which does not allow us to pick or choose which elements we want to assign to variables. To skip the whole array 
it can be done using the number of commas as there is a number of array elements. 

var [firstName,,thirdName] = ["alpha", "beta", "gamma", "delta"];
         
console.log(firstName);//"alpha"
console.log(thirdName);//"gamma"

Example 3: In order to assign some array elements to variable and rest of the array elements to only a single variable can be achieved
by using rest operator (…) as in below implementation. But one limitation of rest operator is that it works correctly only with the last
elements implying a subarray cannot be obtained leaving the last element in the array. 

var [firstName,,...lastName] = ["alpha", "beta", "gamma", "delta"];
         
console.log(firstName);//"alpha"
console.log(lastName);//"gamma, delta"

Example 4: Values can also be swapped using destructuring assignment as below: 

var names = ["alpha", "beta", "gamma", "delta"];
var [firstName, secondName] = names;
console.log(firstName);//"alpha"
console.log(secondName);//"beta"
 
//After swapping
[firstName, secondName] = [secondName, firstName]
     
console.log(firstName);//"beta"
console.log(secondName);//"alpha"


COPY BY REFERENCE (SHALLOW COPY)
--------------------------------
Shallow copy: In the case of shallow copy when we copy the original object into the clone object then the clone object has the copy of 
the memory address of the original object i.e. both point to the same memory address.

Both original object and cloned object internally point to the same referenced object. Since they point to the same memory address so
if we changed the cloned object then changes would be reflected back to the original object.

Example:
let arr = ['a','b','c'];
let arr2 = arr;
  
arr2.push('d');
  
console.log(arr2);
console.log(arr); // even affected the original array(arr) 

Output
[ 'a', 'b', 'c', 'd' ]
[ 'a', 'b', 'c', 'd' ]

In the above code we can clearly see that when we tried to insert an element inside the arr2, the original array is also altered which
we did not intend and is neither recommended. The use of the spread operator is described below.

We can resolve this problem in 2 ways: using spread operator or using loop.

1) Using Spread Operator:

let arr = ['a','b','c'];
let arr2 = [...arr];
  
console.log(arr); // [ 'a', 'b', 'c' ]
  
arr2.push('d'); //inserting an element at the end of arr2
  
console.log(arr2); // [ 'a', 'b', 'c', 'd' ]
console.log(arr); // [ 'a', 'b', 'c' ]

Output
[ 'a', 'b', 'c' ]
[ 'a', 'b', 'c', 'd' ]
[ 'a', 'b', 'c' ]

By using the spread operator we made sure that the original array is not affected whenever we alter the new array.

2) Using Loop:

let arr = ['a','b','c'];
let arr2 = [];

for(let char in arr){
    arr2.push[char];
}

arr2.push(4)
console.log(arr2);
console.log(arr1);

Output:
['a','b','c',4]
['a','b','c']



OBJECTS IN JAVASCRIPT
---------------------
Objects, in JavaScript, is the most important data-type and forms the building blocks for modern JavaScript. These objects are quite
different from JavaScript’s primitive data types (Number, String, Boolean, null, undefined and symbol) in the sense that while these
primitive data-types all store a single value each (depending on their types).

Syntax:

let object_name = {
    key_name : value,
    ...
}


Example:
let school = {
        name: 'Vivekananda School',
        location : 'Delhi',
        established : '1971',
        displayInfo : function(){
            console.log(`${school.name} was established 
                  in ${school.established} at ${school.location}`);
        }
    }
    school.displayInfo(); 

Output
Vivekananda School was established 
                  in 1971 at Delhi


In this example “name”, “location”, “established” are all “keys” and “Vivekananda School”, “Delhi” and 1971 are values of these keys
respectively. Each of these keys is referred to as properties of the object. An object in JavaScript may also have a function as a
member, in which case it will be known as a method of that object. Here  “displayinfo” is a method of the school object that is being
used to work with the object’s data, stored in its properties.

Objects are more complex and each object may contain any combination of these primitive data-types as well as reference data-types.
An object is a reference data type. Variables that are assigned a reference value are given a reference or a pointer to that value. 
That reference or pointer points to the location in memory where the object is stored. The variables don’t actually store the value.
Loosely speaking, objects in JavaScript may be defined as an unordered collection of related data, of primitive or reference types, in
the form of “key: value” pairs. These keys can be variables or functions and are called properties and methods, respectively, in the 
context of an object.
An object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where a key
is a string (also called a “property name”), and the value can be anything.


The objects can be accessed using . and [] also:

1) object_name.property_key
2) object_name["property_key"]; - This is used in cases were the key has a name with spaces between.If we try to access with . operator
                                    error will occur.
                        
But more on the bracket notation later. Property names can also be strings with more than one space separated words. In which case,
these property names must be enclosed in quotes :

let school = {
    "school name" : "Vivekananda School",
}


Like property names which are numbers, they must also be accessed using the bracket notation. Like if we want to access the ‘Vivekananda’
from ‘Vivekananda School’ we can do something like this: 


 // Bracket notation 
    let school = {
        name: 'Vivekananda School',
        displayInfo : function(){
            console.log(`${school.name.split(' ')[0]}`);
        }
    }
    school.displayInfo(); // Vivekananda

Output
Vivekananda
In the above code, we made use of bracket notation and also split method provided by JavaScript.


Function as properties in Javascript
------------------------------------
In JavaScript, functions can be used as properties of objects. This can be a powerful tool for organizing and encapsulating functionality
within an object, making it easier to maintain and reuse code.

To better understand this concept, let's dive into some code examples and interact with them.

Step 1: Defining a Function Property

Let's start by creating an object that contains a function property:

const person = {
  name: "John",
  age: 30,
  sayHello: function() {
    console.log(`Hello,my name is ${this.name}!`);
  }
};
Here, we define an object person with properties name and age, as well as a function property sayHello. This function uses the this
keyword to reference the name property of the object it is called on.

Step 2: Calling the Function Property

Now that we have defined our object with a function property, let's call it:

person.sayHello(); // Output: "Hello, my name is John!"
This will execute the sayHello function and output the message "Hello, my name is John!".

Step 3: Modifying a Function Property

Function properties can also be modified like any other property of an object. Let's modify the sayHello function to change the name of
the person:

person.sayHello = function() {
  console.log(`Hello,my name is ${this.name} Doe!`);
};

Here, we redefine the sayHello function to output a new message with the last name "Doe".

Step 4: Calling the Modified Function Property

Now let's call the modified sayHello function:

person.sayHello(); // Output: "Hello, my name is John Doe!"
This will execute the modified sayHello function and output the message "Hello, my name is John Doe!".

Step 5: Creating Multiple Instances of an Object

JavaScript allows us to create multiple instances of an object, each with its own properties and function properties. Let's create two
instances of our person object:

const person1 = {
  name: "Jane",
  age: 25,
  sayHello: function() {
    console.log(
);
  }
};

const person2 = {
  name: "Bob",
  age: 35,
  sayHello: function() {
    console.log(
);
  }
};
Here, we create two instances of the person object with different values for the name and age properties, as well as their own sayHello
function properties.

Step 6: Calling the Function Property on Multiple Instances

Now let's call the sayHello function on both instances:

person1.sayHello(); // Output: "Hello, my name is Jane!"
person2.sayHello(); // Output: "Hello, my name is Bob!"
This will execute the sayHello function on each instance and output the corresponding message.


Computed Property in objects
----------------------------
Javascript Object:  Javascript objects contain key-value pairs in which the key represents a property from which we can get and set the
value of the object. Now we will see how to declare an object with a computed property name. 

Method 1:  We will use the expression within the [ ] (square bracket) to create the name of an object property. In ES6, it is possible 
to use an expression within brackets ‘[ ]’. Depending on the result of the expression, a property name will be assigned to an object. 


let LAST_NAME = "lastname";
let fullname = {
firstname: "somya",
[LAST_NAME]: "jain"
};
console.log(
"My fullname is: " + fullname.firstname
+ " " + fullname.lastname
);

Output
My fullname is: somya jain
 

Method 2:  In this method, We will create the property name of an object dynamically. As part of this method, we will dynamically create
an object and add a property name and assign a value to that specific property in order to create a customized key-value pair.  

Syntax: objectname["name of the property name"]=value

let LAST_NAME = "lastname";
    let fullname = {
        firstname: "somya"
    };
    fullname[LAST_NAME] = "jain";
    console.log(
        "My fullname is: " + fullname.firstname
            + " " + fullname.lastname
    );

Output
My fullname is: somya jain



Shorthand Property for value in Objects
---------------------------------------
The shorthand syntax for object property value is very popular and widely used nowadays. The code looks cleaner and easy to read. The
shorthand property makes the code size smaller and simpler.

Example: This example displaying the details of object using shorthand Syntax for object property value in ES6.


// Object property shorthand
const name = 'Raj'
const age = 20
const location = 'India'
  
// User with ES6 shorthand
// property 
const user = {
    name,      
    age,
    location
}
  
console.log(user) 

Output
{ name: 'Raj', age: 20, location: 'India' }
 

Example: This example displaying the details of the object without using shorthand Syntax for object property value.


// Object property shorthand
const name = 'Raj'
const age = 20
const location = 'India'
  
// User without ES6 
// shorthand property 
const user = {
    name: name,      
    age: age,
    location: location
}
  
console.log(user) 

Output
{ name: 'Raj', age: 20, location: 'India' }


For-in Loop in Object
---------------------
For-in loop in JavaScript is used to iterate over the properties of an object. It can be a great debugging tool if we want to show the
contents of an object. The for-in loop iterates only over those keys of an object which have their enumerable property set to “true”.
The key values in an object have four attributes : value, writable, enumerable, configurable. Enumerable when set to “true” means that 
we can iterate over that property. You can read about the four key attributes in the property attributes section of Objects in JavaScript.
Read more on enumerable Enumerable Properties in JavaScript.

A simple example to illustrate the for-in loop:


    const list = [10, 20, 30];
    let total = 0;
    for (const item in list) {
        total += list[item];
    }
    console.log(total);

Output
60
Important points:

Use the for-in loop to iterate over non-array objects. Even though we can use for-in loop for array, it is generally not recommended.
Instead, use a for loop for looping over an array.
The properties iterated with for-in loop also includes the properties of the objects higher in the Prototype chain.
The order in which properties are iterated may not match with the properties that are defined in the object.
Syntax: 

for (let i in obj1) {
  
    // Prints all the keys in
    // obj1 on the console
    console.log(i);
 


 const courses = {
 
        // Declaring a courses object
        firstCourse: "C++ STL",
        secondCourse: "DSA Self Paced",
        thirdCourse: "CS Core Subjects"
    };
 
    // Creating a new empty object with
    // prototype set to courses object
    const student1 = Object.create(courses);
 
    // Defining student1 properties and methods
    student1.id = 123;
    student1.firstName = "Prakhar";
    student1.showEnrolledCourses = function () {
        console.log(courses);
    }
 
    // Iterating over all properties of
    // student1 object
    for (let prop in student1) {
        console.log(prop + " -> "
            + student1[prop]);
    }

Output
id -> 123
firstName -> Prakhar
showEnrolledCourses -> function () {
        console.log(courses);
    }
firstCourse -> C++ STL
secondCourse -> DSA Self Paced
thirdCourse -> CS Core Subjects



Object Methods
--------------
1) object.assign() : The Object.assign() method copies properties from one or more source objects to a target object.

   Syntax: Object.assign(target, source)

   Example: 
// Create Target Object
  const person1 = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};

// Create Source Object
const person2 = {firstName: "Anne",lastName: "Smith"};

// Assign Source to Target
Object.assign(person1, person2);

//Output: firstName:Anne,lastName:Smith,age:50,eyeColor:blue


2) object.entries(): ECMAScript 2017 added the Object.entries() method to objects. Object.entries() returns an array of the key/value
                     pairs in an object.

   Syntax: Object.entries(obj);

   Example:
   const person = {
    firstName : "John",
    lastName : "Doe",
    age : 50,
    eyeColor : "blue"
   };

   let text = Object.entries(person);
   //output:
   "firstName : John",
    "lastName : Doe",
    "age : 50",
    "eyeColor : blue"

    Object.entries() makes it simple to use objects in loops:

    Example:
    const fruits = {Bananas:300, Oranges:200, Apples:500};

    let text = "";
    for (let [fruit, value] of Object.entries(fruits)) {
        text += fruit + ": " + value + "<br>";
    }

    Object.entries() also makes it simple to convert objects to maps:

    Example
    const fruits = {Bananas:300, Oranges:200, Apples:500};

    const myMap = new Map(Object.entries(fruits));


3) object.fromEntries() : The fromEntries() method creates an object from a list of key/value pairs.

Syntax: Object.fromEntries(iterable)

Example:
const fruits = [
  ["apples", 300],
  ["pears", 900],
  ["bananas", 500]
];

const myObj = Object.fromEntries(fruits);
console.log(myObj.pears)
//Output: 900


4) object.values() : Object.values() is similar to Object.entries(), but returns a single dimension array of the object values.

Syntax: Object.values(obj)

Example:
const object1 = {
  a: 'somestring',
  b: 42,
  c: false,
};

console.log(Object.values(object1));
// Expected output: Array ["somestring", 42, false]

5) object.keys() : The Object.keys() method returns an array with the keys of an object.

Syntax: Object.keys(obj)

Example:
const object1 = {
  a: 'somestring',
  b: 42,
  c: false,
};

console.log(Object.keys(object1));
// Expected output: Array ["a", "b", "c"]


6) object.groupBy() : The Object.groupBy() method groups elements of an object according to string values returned from a callback 
                      function.

                      The Object.groupBy() method does not change the original object.

Syntax: Object.groupBy(items, callbackFn)

Example:
function myCallback({ quantity }) {
  return quantity > 5 ? "ok" : "restock";
}

const result2 = Object.groupBy(inventory, myCallback);

//Output
{
  restock: [
    { name: "asparagus", type: "vegetables", quantity: 5 },
    { name: "bananas", type: "fruit", quantity: 0 },
    { name: "cherries", type: "fruit", quantity: 5 }
  ],
  ok: [
    { name: "goat", type: "meat", quantity: 23 },
    { name: "fish", type: "meat", quantity: 22 }
  ]
}


7) object.hasOwn() : The Object.hasOwn() static method returns true if the specified object has the indicated property as its own
                     property. If the property is inherited, or does not exist, the method returns false.

Syntax: Object.hasOwn(obj, prop)

Example: 
const object1 = {
  prop: 'exists',
};

console.log(Object.hasOwn(object1, 'prop'));
// Expected output: true

console.log(Object.hasOwn(object1, 'toString'));
// Expected output: false

console.log(Object.hasOwn(object1, 'undeclaredPropertyValue'));
// Expected output: false

Note: Object.hasOwn() is intended as a replacement for Object.prototype.hasOwnProperty().

8) object.is() : The Object.is() static method determines whether two values are the same value

Syntax: Object.is(value1, value2)

Example:
console.log(Object.is('1', 1));
// Expected output: false

console.log(Object.is(NaN, NaN));
// Expected output: true

console.log(Object.is(-0, 0));
// Expected output: false

const obj = {};
console.log(Object.is(obj, {}));
// Expected output: false


9) object.create() : The Object.create() static method creates a new object, using an existing object as the prototype of the newly
                     created object.
Syntax: Object.create(proto) / Object.create(proto, propertiesObject)

Example:
const person = {
  isHuman: false,
  printIntroduction: function () {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  },
};

const me = Object.create(person);

me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // Inherited properties can be overwritten

me.printIntroduction();
// Expected output: "My name is Matthew. Am I human? true"


10) object.defineProperty () : The Object.defineProperties() static method defines new or modifies existing properties directly on an
                               object, returning the object.

Syntax: Object.defineProperties(obj, props)

Example:
const object1 = {};

Object.defineProperties(object1, {
  property1: {
    value: 42,
    writable: true,
  },
  property2: {},
});

console.log(object1.property1);
// Expected output: 42

11) object.defineProperty() : The Object.defineProperty() static method defines a new property directly on an object, or modifies an
                              existing property on an object, and returns the object.

Syntax: Object.defineProperty(obj, prop, descriptor)

Example:
const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false,
});

object1.property1 = 77;
// Throws an error in strict mode

console.log(object1.property1);
// Expected output: 42


12) object.isExtensible() : The Object.isExtensible() static method determines if an object is extensible (whether it can have new
                            properties added to it).

Syntax: Object.isExtensible(obj)

Example: 
const object1 = {};

console.log(Object.isExtensible(object1));
// Expected output: true

Object.preventExtensions(object1);

console.log(Object.isExtensible(object1));
// Expected output: false

13) object.freeze() : The Object.freeze() static method freezes an object. Freezing an object prevents extensions and makes existing 
                      properties non-writable and non-configurable. A frozen object can no longer be changed: new properties cannot
                      be added, existing properties cannot be removed, their enumerability, configurability, writability, or value 
                      cannot be changed, and the object's prototype cannot be re-assigned. freeze() returns the same object that was
                      passed in.

Syntax: Object.freeze(obj)  

Example:
const obj = {
  prop: 42,
};

Object.freeze(obj);

obj.prop = 33;
// Throws an error in strict mode

console.log(obj.prop);
// Expected output: 42


14) object.isFrozen() : The Object.isFrozen() static method determines if an object is frozen.

Syntax: Object.isFrozen(obj)

Example:
const object1 = {
  property1: 42,
};

console.log(Object.isFrozen(object1));
// Expected output: false

Object.freeze(object1);

console.log(Object.isFrozen(object1));
// Expected output: true


15) object.isSealed() : The Object.isSealed() static method determines if an object is sealed.

Syntax: Object.isSealed(obj)

Example:
const object1 = {
  property1: 42,
};

console.log(Object.isSealed(object1));
// Expected output: false

Object.seal(object1);

console.log(Object.isSealed(object1));
// Expected output: true


16) object.preventExtensions() : The Object.preventExtensions() static method prevents new properties from ever being added to an object
                                 (i.e. prevents future extensions to the object). It also prevents the object's prototype from being
                                  re-assigned.

Syntax: Object.preventExtensions(obj)

Example:
const object1 = {};

Object.preventExtensions(object1);

try {
  Object.defineProperty(object1, 'property1', {
    value: 42,
  });
} catch (e) {
  console.log(e);
  // Expected output: TypeError: Cannot define property property1, object is not extensible
}

17) object.seal() : The Object.seal() static method seals an object. Sealing an object prevents extensions and makes existing properties
                    non-configurable. A sealed object has a fixed set of properties: new properties cannot be added, existing properties
                    cannot be removed, their enumerability and configurability cannot be changed, and its prototype cannot be re-assigned.
                    Values of existing properties can still be changed as long as they are writable. seal() returns the same object that 
                    was passed in.

Syntax: Object.seal(obj)

Example:
const object1 = {
  property1: 42,
};

Object.seal(object1);
object1.property1 = 33;
console.log(object1.property1);
// Expected output: 33

delete object1.property1; // Cannot delete when sealed
console.log(object1.property1);
// Expected output: 33





Shallow Copy/Object Reference & Deep Copy in Objects
----------------------------------------------------

Understanding how to copy objects in JavaScript is crucial, especially when dealing with complex data structures. Objects in JavaScript 
are copied by reference, meaning that creating a direct copy of an object does not create a new object but rather a reference to the
original object. This is known as a shallow copy. To create an entirely new object with no references to the original, you need a deep
copy.

Shallow Copy:

A shallow copy creates a new object but does not recursively copy nested objects. Instead, it copies references to the original nested 
objects. Here's an example:

Example of Shallow Copy

const person1 = {
    name: 'Prakash',
    age: 101,
    address: {
        city: 'Mumbai',
        state: 'Maharashtra'
    }
};

const person2 = person1; // Shallow copy
person2.name = 'Ashish';

console.log(person1.name); // Output: Ashish
console.log(person2.name); // Output: Ashish

Output
Ashish
Ashish
 

In this example, changing the name property of person2 also changes the name property of person1 because both variables reference the
same object.

Deep Copy:

A deep copy creates a new object and recursively copies all properties of the original object, ensuring that there are no shared
references between the original and the new object.

Methods to Create Deep Copy
Using JSON methods:

const person1 = {
    name: 'Prakash',
    age: 101,
    address: {
        city: 'Mumbai',
        state: 'Maharashtra'
    }
};

const person2 = JSON.parse(JSON.stringify(person1)); // Deep copy
person2.name = 'Ashish';
person2.address.city = 'Sirsa';

console.log(person1.name); // Output: Prakash
console.log(person2.name); // Output: Ashish
console.log(person1.address.city); // Output: Mumbai
console.log(person2.address.city); // Output: Sirsa

Output
Prakash
Ashish
Mumbai
Sirsa

2. Using a custom deep copy function:

function deepCopy(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    const copy = Array.isArray(obj) ? [] : {};
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            copy[key] = deepCopy(obj[key]);
        }
    }
    return copy;
}

const person1 = {
    name: 'Prakash',
    age: 101,
    address: {
        city: 'Mumbai',
        state: 'Maharashtra'
    }
};

const person2 = deepCopy(person1); // Custom deep copy
person2.name = 'Ashish';
person2.address.city = 'Sirsa';

console.log(person1.name); // Output: Prakash
console.log(person2.name); // Output: Ashish
console.log(person1.address.city); // Output: Mumbai
console.log(person2.address.city); // Output: Sirsa

Output
Prakash
Ashish
Mumbai
Sirsa
Object.assign
The Object.assign method creates a shallow copy of an object. It is useful for copying objects that do not contain nested objects.

Example of Object.assign

const person1 = {
    name: 'Prakash',
    age: 101
};

const person2 = Object.assign({}, person1); // Shallow copy
person2.name = 'Ashish';

console.log(person1.name); // Output: Prakash
console.log(person2.name); // Output: Ashish

Output
Prakash
Ashish
However, when using Object.assign with nested objects, the nested objects are still copied by reference, leading to unexpected behavior:


const person1 = {
    name: 'Prakash',
    age: 101,
    address: {
        city: 'Mumbai',
        state: 'Maharashtra'
    }
};

const person2 = Object.assign({}, person1); // Shallow copy
person2.name = 'Ashish';
person2.address.city = 'Sirsa';

console.log(person1.address.city); // Output: Sirsa
console.log(person2.address.city); // Output: Sirsa

Output
Sirsa
Sirsa
Spread Operator
The spread operator (...) can also be used to create a shallow copy of an object:

Example of Spread Operator

const person1 = {
    name: 'Prakash',
    age: 101,
    address: {
        city: 'Mumbai',
        state: 'Maharashtra'
    }
};

const person2 = { ...person1 }; // Shallow copy
person2.name = 'Ashish';
person2.address.city = 'Sirsa';

console.log(person1.name); // Output: Prakash
console.log(person2.name); // Output: Ashish
console.log(person1.address.city); // Output: Sirsa
console.log(person2.address.city); // Output: Sirsa

Output
Prakash
Ashish
Sirsa
Sirsa
Again, for nested objects, the spread operator does not create a deep copy.

Summary
Shallow Copy: A shallow copy duplicates the top-level properties but does not recursively copy nested objects. Methods like Object.assign
and the spread operator (...) create shallow copies.

Deep Copy: A deep copy duplicates all properties, including nested objects, ensuring that no references are shared between the original 
and the copied object. Methods like JSON.parse(JSON.stringify(obj)) and custom recursive functions can create deep copies.
Understanding the difference between shallow and deep copies is crucial for managing and manipulating objects effectively in JavaScript.


OPTIONAL CHAINING IN JAVASCRIPT
-------------------------------
The optional chaining ‘?.’ is an error-proof way to access nested object properties, even if an intermediate property doesn’t exist. It
was recently introduced by ECMA International, Technical Committee 39 – ECMAScript which was authored by Claude Pache, Gabriel Isenberg,
Daniel Rosenwasser, Dustin Savery. It works similar to Chaining ‘.’ except that it does not report the error, instead it returns a value
which is undefined. It also works with function call when we try to make a call to a method which may not exist.

When we want to check a value of the property which is deep inside a tree-like structure, we often have to perform check whether
intermediate nodes exist.

let Value = user.dog && user.dog.name;
 

The Optional Chaining Operator allows a developer to handle many of those cases without repeating themselves and/or assigning
intermediate results in temporary variables:

let Value = user.dog?.name;
 

Syntax: 

obj?.prop
obj?.[expr]
arr?.[index]
func?.(args)

Example:

let user1 = () => console.log("Alex");
let user2 = {
  dog(){
    console.log("I am Alex");
  }
}
let user3 = {};
 
user1?.();       // Alex
user2.dog?.();   // I am Alex
user3.dog();     // ERROR - Uncaught TypeError:
                 // user3.dog is not a function.
user3.dog?.();   // Will not generate any error.
 




Nested Objects
Consider an object user with properties name, address, and likes. The address property itself is an object containing street and city:


const user = {
    name: 'Prakash',
    address: {
        street: '123 Main St',
        city: 'Mumbai'
    },
    likes: ['reading', 'traveling']
};


To access the city from the address, you can write:

console.log(user.address.city); // Output: Mumbai
 However, if the city property does not exist or the address is undefined, you will encounter issues:

console.log(user.address.landmark); // Output: undefined
console.log(user.hobbies); // Output: undefined
The real problem arises when the address itself is not defined:


const userWithoutAddress = {
    name: 'Prakash'
};

console.log(userWithoutAddress.address.city); // Error: Cannot read property 'city' of undefined
Optional Chaining
Optional chaining allows you to safely access nested properties. It uses the ?. syntax to check if a property exists before trying to
access it.

Example with Nested Properties
Using optional chaining, you can safely access city:

console.log(user?.address?.city); // Output: Mumbai
console.log(userWithoutAddress?.address?.city); // Output: undefined
Example with Functions
Optional chaining also works with functions:


const userWithFunction = {
    name: 'Prakash',
    getDisplayMessage: function() {
        console.log('Welcome, Prakash');
    }
};

userWithFunction?.getDisplayMessage?.(); // Output: Welcome, Prakash

const userWithoutFunction = {
    name: 'Prakash'
};

userWithoutFunction?.getDisplayMessage?.(); // No output, no error
 

Practical Use Case
Optional chaining is especially useful when dealing with data from APIs where some properties may be optional:


fetch('https://api.example.com/user')
    .then(response => response.json())
    .then(data => {
        console.log(data?.address?.city);
    });
Exercise
Try to implement optional chaining using square brackets for computed properties.

const key = 'address';
console.log(user[key]?.city); // Output: Mumbai


Summary
Optional Chaining: Uses ?. to safely access nested properties and methods.
Avoids Errors: Prevents errors when properties do not exist.
Usage: Useful for optional or nullable properties.
Key Points
Nested Properties: Use ?. to access nested properties safely.
Functions: Use ?.() to call functions safely.
Avoid Overuse: Only use optional chaining when necessary.



Destructuring Object
--------------------

Destructuring is an important and frequently used concept in JavaScript, especially when dealing with complex objects or arrays, such as
those returned from API responses. It allows for the unpacking of values from arrays or properties from objects into distinct variables.
Let's delve into the concept and see how it can be effectively used.


Basic Destructuring:
--------------------
Consider an object with multiple properties:


const obj = {
    name: 'Prakash',
    address: {
        street: '123 Main St',
        city: 'Mumbai',
        state: 'Maharashtra'
    },
    courses: ['JavaScript', 'React', 'Node.js']
};
To extract the name, address, and courses properties, you can use object destructuring:


const { name, address, courses } = obj;
console.log(name); // Output: Prakash
console.log(address); // Output: { street: '123 Main St', city: 'Mumbai', state: 'Maharashtra' }
console.log(courses); // Output: ['JavaScript', 'React', 'Node.js']
 

Nested Destructuring:
---------------------
To access nested properties directly:


const { address: { city, state } } = obj;
console.log(city); // Output: Mumbai
console.log(state); // Output: Maharashtra

Renaming Variables:
-------------------
You can rename the variables while destructuring:


const { name: userName, address: { city: userCity } } = obj;
console.log(userName); // Output: Prakash
console.log(userCity); // Output: Mumbai
 

Using Rest Operator:
-------------------
To gather remaining properties into a new object:


const { name, ...rest } = obj;
console.log(name); // Output: Prakash
console.log(rest); // Output: { address: { street: '123 Main St', city: 'Mumbai', state: 'Maharashtra' }, courses: ['JavaScript', 
'React', 'Node.js'] }
 

Practical Example with Nested Objects:
--------------------------------------
Consider an API response with deeply nested objects:


const employees = {
    engineers: {
        emp1: { id: 1, name: 'John Doe', occupation: 'Software Engineer' },
        emp2: { id: 2, name: 'Jane Smith', occupation: 'Data Scientist' }
    },
    placement: {
        emp3: { id: 3, name: 'Emily Jones', occupation: 'HR Manager' }
    },
    youtube: {
        emp4: { id: 4, name: 'Chris Brown', occupation: 'Content Creator' }
    }
};
To extract specific details, you can use nested destructuring:


const { engineers: { emp2: { name: engineerName, occupation: engineerOccupation } } } = employees;
console.log(engineerName); // Output: Jane Smith
console.log(engineerOccupation); // Output: Data Scientist

Destructuring with Dynamic Property Names:
-----------------------------------------
You can use computed property names when destructuring:


const propName = 'engineers';
const { [propName]: engineers } = employees;
console.log(engineers); // Output: { emp1: { id: 1, name: 'John Doe', occupation: 'Software Engineer' }, emp2: { id: 2, name: 'Jane Smith'
, occupation: 'Data Scientist' } }

Summary
-------
Destructuring is a powerful feature that allows you to write cleaner and more readable code by unpacking values from arrays or objects 
into distinct variables. It is especially useful when dealing with complex data structures, such as those returned from APIs. Practice
destructuring with various objects and arrays to become proficient in using this feature.


"this" Keyword in JavaScript (Also called as Implicit Binding)
--------------------------------------------------------------

Unlike some other programming languages, the this keyword in JavaScript can be a bit tricky because it behaves differently depending
on the context in which it is used. Let's break it down.

1) The "this" Keyword in Objects:
The "this" keyword in JavaScript typically refers to the object that is executing the function. When a function is a property of an
object (also called a method), this inside that function refers to the object itself.

Example:

const obj = {
    name: "Prakash",
    displayMessage: function() {
        console.log(this);
    }
};

obj.displayMessage(); // Logs the obj object
In this example, this inside the displayMessage function refers to the obj object. When you run the code, it logs the obj object to the 
console.


2) Using "this" Inside Methods:
If you want to access properties of the object within a method, you can use this:


const obj = {
    name: "Prakash",
    displayMessage: function() {
        console.log("Hello, " + this.name);
    }
};

obj.displayMessage(); // Logs "Hello, Prakash"
Here, this.name refers to the name property of the obj object.


3) "this" in Global Context:
When "this" is used inside a regular function (not an object method), it usually refers to the global object, which is window in browsers.

Example:

function showThis() {
    console.log(this);
}

showThis(); // Logs the global object (window in browsers)
Even though showThis is a function, because it's not attached to any object, this refers to the global object.

4) Arrow Functions and "this":
Arrow functions are special because they don’t have their own "this". Instead, they inherit "this" from the surrounding scope.

Example:

const obj = {
    name: "Prakash",
    displayMessage: () => {
        console.log(this.name);
    }
};

obj.displayMessage(); // Logs undefined
In this example, this.name is undefined because this in an arrow function refers to the surrounding (global) scope, not the obj object.


5) Regular Functions vs. Arrow Functions:
Regular Functions: this refers to the object that calls the method.
Arrow Functions: this is inherited from the surrounding scope.

6) "this" Inside Nested Functions:
Sometimes, you might encounter nested functions. If you use this inside a nested function, it won't refer to the outer function’s "this"
by default. Instead, it will refer to the global object.

Example:

const obj = {
    name: "Prakash",
    showName: function() {
        function display() {
            console.log(this.name);
        }
        display();
    }
};

obj.showName(); // Logs undefined
In this case, this inside the display function refers to the global object, not obj. Because "this" inside display() function is not a
property of obj object and it is not executed by object as well. 

Solution: Using self or that
A common workaround is to store this in a variable (often named self or that) that the inner function can access:


const obj = {
    name: "Prakash",
    showName: function() {
        const self = this;
        function display() {
            console.log(self.name);
        }
        display();
    }
};

obj.showName(); // Logs "Prakash"
Here, self refers to obj, so self.name correctly logs "Prakash".

Summary:
In Methods: "this" refers to the object executing the method.
In Regular Functions: "this" refers to the global object (window in browsers).
In Arrow Functions: "this" is inherited from the surrounding scope.
In Nested Functions: "this" can refer to the global object unless explicitly bound to the outer context using self.
Understanding "this" is crucial for mastering JavaScript, as it affects how functions and objects interact with each other. In the next 
lesson, we'll explore how to explicitly set the value of this using call, apply, and bind. See you there!


Constructor " New "
-------------------

In this, we'll explore the concept of constructor functions and the new keyword in JavaScript. Constructor functions are essentially
regular functions, but with two key differences:

1. They are named with a capital letter.
2. They can only be executed using the new keyword.

Creating a Constructor Function
Let's start by defining a constructor function:


function User(name, age) {
    this.name = name;
    this.age = age;
}

Using the new Keyword
To create an instance of the User constructor function, you use the new keyword. This keyword ensures that a new object is created and
that the function is executed with its this keyword set to that new object.

const user1 = new User('Prakash', 101);
console.log(user1); // Output: User { name: 'Prakash', age: 101 }

Without the new keyword, the function would not create a new object, and the "this" keyword would refer to the global object (or be 
undefined in strict mode). Using "new" ensures that "this" refers to the newly created object.



Adding Properties with "this":
In the constructor function, properties are added to the object being created using the "this" keyword:

function User(name, age) {
    this.name = name;
    this.age = age;
}

const user1 = new User('Prakash', 101);
const user2 = new User('Ashish', 25);

console.log(user1.name); // Output: Prakash
console.log(user2.age);  // Output: 25

Output
Prakash
25

const user1 = new User('Prakash', 101);
const user2 = new User('Ashish', 25);
const user3 = new User('Ria', 99);
const user4 = new User('Sagar', 100);

console.log(user1); // Output: User { name: 'Prakash', age: 101 }
console.log(user2); // Output: User { name: 'Ashish', age: 25 }
console.log(user3); // Output: User { name: 'Ria', age: 99 }
console.log(user4); // Output: User { name: 'Sagar', age: 100 }



Creating Multiple Objects:

You can use the constructor function to create multiple objects efficiently:


const user1 = new User('Prakash', 101);
const user2 = new User('Ashish', 25);
const user3 = new User('Ria', 99);
const user4 = new User('Sagar', 100);

console.log(user1); // Output: User { name: 'Prakash', age: 101 }
console.log(user2); // Output: User { name: 'Ashish', age: 25 }
console.log(user3); // Output: User { name: 'Ria', age: 99 }
console.log(user4); // Output: User { name: 'Sagar', age: 100 }
 


Output
User { name: 'Prakash', age: 27 }
User { name: 'Ashish', age: 25 }
User { name: 'Sadaf', age: 25 }
User { name: 'Rohan', age: 28 }



The "this" Keyword in Constructor Functions:

The "this" keyword inside a constructor function refers to the newly created object. This is why we use this to assign properties to the
object.

Example
Let's log the value of "this" inside the constructor function to see what it refers to:


function User(name, age) {
    this.name = name;
    this.age = age;
    console.log(this);
}

const user1 = new User('Prakash', 101);
// Output: User { name: 'Prakash', age: 101 }
As you can see, "this" refers to the new object created by the "new" keyword.

Summary
Constructor Functions: Special functions used to create and initialize objects.
new Keyword: Creates a new object and sets the this keyword in the constructor function to that new object.
Adding Properties: Use the this keyword to add properties to the object within the constructor function.
By using constructor functions and the "new" keyword, you can efficiently create multiple objects with similar properties and methods, 
making your code more modular and maintainable.

Keep practicing and experimenting with constructor functions to strengthen your understanding.


Function Borrowing - call and apply (also called as Explicit Binding)
---------------------------------------------------------------------

In this Article, we'll discuss the concept of function borrowing in JavaScript using the call and apply methods. Function borrowing allows
one object to borrow methods from another object without making a copy of that method. This is particularly useful to avoid code 
repetition and make the code more modular and maintainable.

Understanding Function Borrowing
Suppose we have three objects representing users, each with a name and age property, and a sayHi method to display their name. Instead
of defining the sayHi method for each object, we can define it once and let the objects borrow this method.

Initial Setup

const user1 = {
    name: 'Prakash',
    age: 25,
};

const user2 = {
    name: 'Ashish',
    age: 30,
};

const user3 = {
    name: 'Suresh',
    age: 35,
};

function sayHi() {
    console.log(this.name);
}


Now, let's say we want to borrow the greet method from person1 and use it on person2. We can do this using the call() or apply() methods.

TUsing Call

The call method allows us to borrow a function and execute it with a specified this value and arguments. Here's how it works:

sayHi.call(user1); // Output: Prakash
sayHi.call(user2); // Output: Ashish
sayHi.call(user3); // Output: Suresh
The call method immediately invokes the function with the this value set to the specified object.

Using Apply
The apply method works similarly to call, but it takes an array of arguments instead of individual arguments. This can be particularly 
useful when you have an array of arguments to pass.


function introduce(degree, year) {
    console.log(`${this.name}, Degree: ${degree}, Year: ${year}`);
}

introduce.apply(user1, ['B.Tech ECE', 2015]); // Output: Prakash, Degree: B.Tech ECE, Year: 2015
introduce.apply(user2, ['B.Tech CS', 2018]); // Output: Ashish, Degree: B.Tech CS, Year: 2018
Example of Function Borrowing
Let's look at a complete example to see how function borrowing can help us avoid repetition and keep the code clean.


const user1 = {
    name: 'Prakash',
    age: 25,
};

const user2 = {
    name: 'Ashish',
    age: 30,
};

const user3 = {
    name: 'Suresh',
    age: 35,
};

function sayHi() {
    console.log(`Hi, my name is ${this.name}.`);
}

// Borrowing the sayHi function
sayHi.call(user1); // Output: Hi, my name is Prakash.
sayHi.call(user2); // Output: Hi, my name is Ashish.
sayHi.call(user3); // Output: Hi, my name is Suresh.

// Using apply with arguments
function introduce(degree, year) {
    console.log(`${this.name}, Degree: ${degree}, Year: ${year}`);
}

introduce.apply(user1, ['B.Tech ECE', 2015]); // Output: Prakash, Degree: B.Tech ECE, Year: 2015
introduce.apply(user2, ['B.Tech CS', 2018]); // Output: Ashish, Degree: B.Tech CS, Year: 2018
Summary
Call: Immediately invokes the function with a specified this value and arguments.
Apply: Immediately invokes the function with a specified this value and arguments passed as an array.


Function Borrowing using bind (returns the function)
------------------------------

In this Article, we'll discuss the concept of function borrowing in JavaScript using the bind method. 

Understanding Function Borrowing with Bind

The bind method creates a new function that, when called, has its this keyword set to the provided value. Unlike call and apply, bind
does not immediately invoke the function. Instead, it returns a new function that can be invoked later.

Here's how you can use bind to borrow the sayHi function for each user:

const boundSayHiUser1 = sayHi.bind(user1);
const boundSayHiUser2 = sayHi.bind(user2);
const boundSayHiUser3 = sayHi.bind(user3);

boundSayHiUser1(); // Output: Hi, my name is Prakash.
boundSayHiUser2(); // Output: Hi, my name is Ashish.
boundSayHiUser3(); // Output: Hi, my name is Ria.
Passing Arguments with Bind
The bind method can also be used to partially apply arguments to the function. This is useful if your function takes additional 
parameters.

Let's modify our sayHi function to take additional parameters and use bind to pass these arguments:


function introduce(degree, year) {
    console.log(`${this.name}, Degree: ${degree}, Year: ${year}`);
}

const boundIntroduceUser1 = introduce.bind(user1, 'B.Tech ECE', 2015);
const boundIntroduceUser2 = introduce.bind(user2, 'B.Tech CS', 2018);
const boundIntroduceUser3 = introduce.bind(user3, 'B.Tech CS', 2022);

boundIntroduceUser1(); // Output: Prakash, Degree: B.Tech ECE, Year: 2015
boundIntroduceUser2(); // Output: Ashish, Degree: B.Tech CS, Year: 2018
boundIntroduceUser3(); // Output: Ria, Degree: B.Tech CS, Year: 2022
Flexibility with Bind
The flexibility of bind allows us to create reusable and modular code. It can also be used in event handlers and other scenarios where 
the function needs to be invoked later.

Here's an example of using bind in an event handler:

In this example, the boundSayHiUser1 function will be invoked when the button is clicked, and it will have its this keyword set to user1.

Summary
Bind: Creates a new function that can be invoked later, with the this value permanently set to the specified object.
Function Borrowing: Allows one object to use a method defined in another object.
Partial Application: Bind can be used to partially apply arguments to a function, creating a new function with pre-set arguments.
By using bind, we can keep our code clean, modular, and maintainable while avoiding code repetition.

Keep practicing this and solving questions around this concept to get a good hold of it. I'll see you in the next lesson. Bye-bye!


const button = document.createElement('button');
button.textContent = 'Click me';
document.body.appendChild(button);

button.addEventListener('click', boundSayHiUser1);










EXECUTION CONTEXT IN JAVASCRIPT
-------------------------------
Introduction
Execution context is a fundamental concept in JavaScript that dictates how the code is executed. Unlike many other programming languages,
JavaScript handles code execution in a unique way, making it essential to understand this concept thoroughly.

Browser and JavaScript Engine
When a browser encounters JavaScript code, it activates the JavaScript engine. Each browser has its own JavaScript engine (e.g., V8 in
Chrome, SpiderMonkey in Firefox).

Execution Context in Javascript

Browser -> JavaScript Engine 

Execution Context
The JavaScript engine creates an environment called the execution context to execute the code. This environment manages the memory 
allocation and the execution of the code.

Types of Execution Context
1. Global Execution Context (GEC): Created when the JavaScript engine starts executing the code. There is only one GEC per JavaScript file.

A single global execution context is created for a single JS file. When a browser runs the code it runs a single JS file even if you are
using any frontend libraries like react angular etc that contain multiple JS files. Webpack bundles all the different files into a 
single JS file and parses it. So it is important to remember that only one global execution context is created for a JS file. Although
for different function invocations, multiple functional executions context gets created.

2. Functional Execution Context (FEC): Created whenever a function is invoked. There can be multiple FECs depending on the number of 
                                        function calls.

Components of Execution Context:
1. Variable Object: Contains variable and function declarations.
2. Scope Chain: Manages the scope and scope chain.
3. this Keyword: Sets the value of this.

Creation of Execution Context
Execution context is created in two phases:

1. Creation Phase:
Memory allocation for variables and functions.
Variables declared with var are assigned undefined.
Function declarations are assigned the function definition.

2. Execution Phase:
Code is executed line by line.
JavaScript is a single-threaded synchronous language, meaning it executes one line of code at a time in order.

In the creation phase JS engine skims through the code and extracts variable declarations and function declarations and assigns variable
declarations with undefined and function declarations with complete function code in the form of key-value pair. Only variables declared
with the var keyword are extracted not let and const.

In the creation phase variable environment is created and it will store everything in the form of key-value pair.

In the execution phase thread of execution is created where the code gets executed line by line in a synchronous manner as JavaScript 
is a single-thread synchronous language.

Note: single threaded means one line executed at a time and synchronous means it will only executes sequentialy like 1st line, 2nd, 3rd
      not 1st,2nd,4rth or 7th.

Example - Consider the following code:

console.log("Global Context Start");

function foo() {
    console.log("Inside foo");
}

function bar() {
    console.log("Inside bar");
    foo();
}

bar();
console.log("Global Context End");

Global Execution Context (GEC)
Creation Phase:
console is identified.
foo and bar are function declarations.
Execution Phase:
console.log("Global Context Start") is executed.
bar() is called, creating a new FEC.

Functional Execution Context (FEC)
When bar() is called:

Creation Phase:
console is identified.
foo is identified within bar.
Execution Phase:
console.log("Inside bar") is executed.
foo() is called, creating a new FEC.
When foo() is called:

Creation Phase:
console is identified.
Execution Phase:
console.log("Inside foo") is executed.


Call Stack

The call stack maintains the order of execution contexts:

Start:
Call Stack: [Global Execution Context]
Executing bar():
Call Stack: [Global Execution Context, bar Execution Context]
Executing foo() inside bar:
Call Stack: [Global Execution Context, bar Execution Context, foo Execution Context]
Completion of foo():
Call Stack: [Global Execution Context, bar Execution Context]
Completion of bar():
Call Stack: [Global Execution Context]
Completion of Global Execution:
Call Stack: []
Importance of Understanding Execution Context
Understanding execution context is crucial for several reasons:

Code Execution: It helps in understanding how JavaScript executes code line by line.
Debugging: It aids in debugging by showing the sequence of function calls.
Memory Management: It helps in understanding how memory is allocated and deallocated.
Conclusion
Execution context is a vital concept in JavaScript that dictates how code is executed. By understanding the creation and execution phases of the execution context and how the call stack works, you can write more efficient and bug-free code. This foundational knowledge will also help you grasp more advanced concepts like closures, asynchronous programming, and event loops.
















HOW JS CODE IS EXECUTED
-----------------------
Note:In creation phase only variable declared with var will be assigned undefined. 

How JavaScript code is executed concerning the execution context.

JavaScript Execution Context: An Overview
Whenever JavaScript encounters a code snippet, it activates the JavaScript engine, which creates an environment called the execution 
context. This context is created in two phases:

Creation Phase: Allocates memory to variables and functions.
Execution Phase: Executes the code line by line.

Execution Phases Explained

Creation Phase
In the creation phase, the JavaScript engine:
Scans through the code.
Allocates memory for variables declared with var and function declarations.
Assigns undefined to variables and stores the function definitions.

Execution Phase
In the execution phase, the JavaScript engine: 
Executes the code line by line.
Updates the values of variables and executes functions.


Sample Code Execution
Consider the following sample code:


Now we write a demo code below and we will say line by line, how the code run.  


var n = 3;
function squr(num) {
    var ans = num * num;
    return ans;
}
var three = squr(n);

When you run this whole code a global EXECUTION CONTEXT is created and it contains two parts one is memory and the other is code 
execution.

When the first line is encountered it will reserve memory for all variables(n, three, five) and function(square). When reserving the 
memory for variables it reserves a special value undefined and for function, it stores whole code. 



After allocating memory for all variables and function, code execution phase starts(code runs line by line).

Line 1: var n=3,  3 value placed into the n identifier.

Line 2-5: nothing to execute.

Line:6: we invoke a function, now function is the heart of JavaScript. The function is a mini-program and whenever a new function is
invoked all together a new EXECUTION CONTEXT is created(inside the code execution phase). It also contains two-part memory and code
execution phase. Memory is allocated for variable and function(it involves function parameters and other variables).




After allocating memory, the code execution phase comes here the code inside the function executes, and undefined is replaced by the
actual value.


 
After that, when 'return' is encountered, the control of the program is returned to the place where the function is invoked. The control
goes to line 6, finding the answer in the local memory. The control then returns to line 3, and the value of 'three' (undefined) is
replaced by the value of 'ans'. After that, the entire execution context is deleted.


After that Global Execution Context is Deleted and our program ends. And One more thing, JavaScript Handle everything deleted and
created (to manage the execution context) it’s managing a stack. It's name CALL STACK. It’s a Stack that maintains the order of 
execution. 

Conclusion
The execution context is crucial for understanding how JavaScript code is executed. It consists of the creation phase, where memory is 
allocated, and the execution phase, where the code is executed line by line. The call stack helps manage the execution order of multiple
functions, ensuring that JavaScript remains a single-threaded synchronous language. Understanding these concepts is fundamental for
writing efficient and bug-free JavaScript code.


CALLSTACK IN JAVASCRIPT
-----------------------
In order to manage Different Execution Contexts, we have something called as CallStack present in the javascript runtime. The job of the
call stack is to manage and run execution contexts created while executing the code. Let's try to understand this with the help of an
example.

var x = 5 ; // Line 1
function getSum(num){
 var y=7 ;
 var total = num + y ;
 return total ;

}

var result1 = getSum(x); // Line 9
var result2 = getSum(9); // Line 10

 

Once the code execution starts, the Global execution context is created and it will sit on the bottom of Callstack . Once the code
execution reaches Line 9  new Function execution context is created for the getSum and now it will sit on the top of Callstack . 
Similarly, this function will get executed line by line, and once finished it will be popped out of the Callstack then execution for 
GEC will resume and once it gets finished it will also be popped out of the stack.

In order to see how does this call stack looks like Go to Devtools => Sources => CallStack
Put a debugger at line 1 and you will see anonymous inside CallStack Tab.


HOISTING IN JAVASCRIPT
----------------------
JS code is interpreted in two passes.

* On the first pass, the interpreter
  Variables [not initializers] and function declarations.
* The second pass is the actual code execution step processed by an interpreter
  Variables that are not declared as function expressions.

Therefore, we can use the concept of "hoisting" to describe such behavior.

In Laymen's terms, Hoisting is a process whereby you can access the value of a variable or function even before it is initialized.

 
console.log(age);
showName();

var age = 60 ;

function showName(){
 console.log("Prakash Sakari");
}

Output
undefined
Prakash Sakari
 

Let us Understand the output 

We can see that the console.log(age) prints the output as undefined .This is due to hoisting.
During the creation phase of the Execution context, memory assigned to variable age is undefined. So when we try to access the age
console prints undefined.


For the function named showName, we can see that we are able to invoke it before declaration as during the creation phase it was already
available in the memory . Also if we try to console.log(showName) whole body of the function is printed. 
 

Now let us see how hoisting works in the case of a regular function expression 


console.log(getname);

var getname = function shwname(){
 console.log(getname);
}

Output
undefined

In the above code when we try to access variable getname , the value is undefined it is due to the fact that the memory is treating
getname as a variable in the creation phase not as a function so we get undefined as an output.
You can also put a debugger and run the code in chrome dev tools and check in the scope section how variables and functions are assigned
values during the creation phase and the execution phase.

Hoisting with let and const:

Hoisting with let and const is different. They are hoisted but not initialized, resulting in a ReferenceError if accessed before 
initialization:


console.log(x); // Throws ReferenceError: Cannot access 'x' before initialization
let x = 9;

console.log(y); // Throws ReferenceError: Cannot access 'y' before initialization
const y = 10;

Key Takeaways:
Hoisting: Variables declared with var and function declarations are hoisted to the top of their scope.
Function Expressions: Treated as variables, and thus, initialized to undefined during hoisting.
Temporal Dead Zone: let and const variables are hoisted but not initialized, resulting in a ReferenceError if accessed before
initialization.

Hoisting is an essential concept in JavaScript that allows for accessing variables and functions before their actual declaration in the
code. Understanding this behavior can help avoid common pitfalls and write more predictable JavaScript code.



Hoisting in terms of let and const
----------------------------------
Here, we are going to understand how hoisting works in let and const variable declarations.
There is a lot of misconception about whether hoisting happens in let and const. Most people think since we cannot access let and const
declared variables before initialization there is no hoisting phenomenon in let and const but that is not the case in JavaScript.

Let us Try to understand this with different examples.

Example-1:


let x=10 ;
var y=11 ;
console.log(x); 
console.log(y); 

Output
10
11
 

Output is 10 and 11 as expected.

Now let us Tweak it a little bit and see what happens when we try to access x and y before initializing them 

Example-2:


console.log(y);
console.log(x);
let x = 10;
var y = 11;

If You try to Run the above code it will show an error saying "ReferenceError: Cannot access 'x' before initialization".

Now Let us see what happens when we try to access a variable that is not even declared in a JS Programme

Example-3:


console.log(a);

Upon running the above code You will see an error saying "ReferenceError: a is not defined"

Now here comes the answer to the initial question of whether hoisting occurs in let and const or not. If You look closely at example 2
the error says cannot access x before initialization but in example three the error is "a is not defined". Since we can clearly see the
error in the example is about not accessing variable x before initialization it means that it must have existed somewhere in the memory
before initialization but we are unable to access it. this special place in memory that we cannot access is known as the Temporal Dead
zone.

So let and const are hoisted but they exist in Temporal Dead Zone.

So what is TDZ?

TDZ is the term to describe the state where variables are unreachable. They are in scope, but they aren't declared. The let and const
variables exist in the TDZ from the start of their enclosing scope until they are declared.

In easier terms, it is a time period from where the variable is hoisted till the time when the variable is initialized with a value.

Temporal Dead Zone:
1. The TDZ starts from the beginning of the block scope.
2. The TDZ ends when the variable is initialized.

//TDZ starts here 
console.log(y);
console.log(x);
let x = 9 ; //TDZ ends here 
console.log(x);


Key Takeaways:

* Hoisting: let and const variables are hoisted but exist in the TDZ until initialization.
* TDZ: The period from the start of the block until the variable is initialized.
* Errors: Accessing a variable in the TDZ results in a ReferenceError.




PURE FUNCTION IN JAVASCRIPT
---------------------------

Pure functions are a fundamental concept in programming, especially when working with functional programming paradigms and frameworks
like React. They are important because they ensure predictability and reliability in your code. Let's break down what makes a function
"pure" and why it's crucial to understand this concept.

What is a Pure Function?
A pure function has the following characteristics:

1. Takes Input (Arguments): It should accept parameters and use those inputs to produce a result.
2. Returns a Value: It always returns a value.
3. No Side Effects: The output of the function should not depend on any external state or variables outside of its scope. This means the
function should not modify any external state (like global variables or passed-in objects/arrays).
4. Deterministic: Given the same input, a pure function will always return the same output. This predictability is a key aspect of pure 
functions.

Also a pure function does not produce any observable side effects such as network requests or data mutation etc.

Example of a Pure Function
Here’s a simple example:

function doubleValue(number) {
    return number * 2;
}

const result = doubleValue(5);
console.log(result); // 10
This function is pure because:

It takes an input (number).
It returns a value (number * 2).
It doesn't modify any external variables.
The result is always the same for the same input.



Impure Function Example
Let's see an example of an impure function:

const multiplier = 4;

function doubleValue(number) {
    return number * multiplier;
}

const result = doubleValue(5);
console.log(result); // 20

This function is impure because:

It relies on an external variable (multiplier).
If multiplier changes, the output changes even if the input (number) stays the same.
It’s no longer predictable since it depends on external state.
Avoiding Mutation
Another characteristic of pure functions is that they do not mutate their input values. Let's consider an example that mutates an array:


function appendNumbers(arr) {
    arr.push(5, 6);
    return arr;
}

const numbers = [1, 2, 3, 4];
const result = appendNumbers(numbers);
console.log(result); // [1, 2, 3, 4, 5, 6]
This function is impure because it mutates the original array. The arr that is passed into the function is directly modified.

Making it Pure
To make this function pure, you should avoid mutating the original array:


function appendNumbers(arr) {
    const newArr = [...arr, 5, 6];
    return newArr;
}

const numbers = [1, 2, 3, 4];
const result = appendNumbers(numbers);
console.log(result); // [1, 2, 3, 4, 5, 6]
console.log(numbers); // [1, 2, 3, 4] (original array remains unchanged)

Here’s why this is a pure function:

It creates a new array (newArr) instead of modifying the original one.
It returns this new array, leaving the original array intact.


Why Pure Functions Matter
Pure functions are essential for several reasons:

1. Predictability: Since pure functions always produce the same output for the same input, they are easy to reason about and debug.
2. Testability: Pure functions are easier to test because they don't rely on external state.
3. Concurrency: Pure functions don’t have side effects, so they are safe to run in parallel or in a concurrent environment.
4. React and Functional Programming: Many modern frameworks and libraries, such as React, rely heavily on the principles of pure 
functions to manage state and UI rendering efficiently.

Summary
A pure function in JavaScript:

Accepts inputs and returns a value.
Does not rely on or modify external state.
Always produces the same output for the same input.
Understanding and writing pure functions is crucial for writing clean, maintainable, and bug-free code. As you continue to work with
    JavaScript and frameworks like React, you'll see how important pure functions are in practice.


But here we need to make an important note:

Note: If a pure function calls a pure function, this isn’t a side effect and the calling function is still considered pure. (Example:
using Math.max() inside a function)

Below are some side effects (but not limited to) which a function should not produce in order to be considered as a pure function -

Making a HTTP request
Mutating data
Printing to a screen or console
DOM Query/Manipulation
Math.random()
Getting the current time


FIRST CLASS FUNCTION IN JAVASCRIPT
----------------------------------
First-Class Function: A programming language is said to have First-class functions if functions in that language are treated like other
variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function.
In JavaScript, functions are treated as "first-class citizens." But what does this mean? It means that functions in JavaScript have the 
same status as other data types like strings, numbers, or objects.

Example: Let us take an example to understand more about the first-class function.


const Arithmetics = {
add: (a, b) => {
return `${a} + ${b} = ${a + b}`;
},
subtract: (a, b) => {
return `${a} - ${b} = ${a - b}`
},
multiply: (a, b) => {
return `${a} * ${b} = ${a * b}`
},
division: (a, b) => {
if (b != 0) return `${a} / ${b} = ${a / b}`;
return `Cannot Divide by Zero!!!`;
}

}

console.log(Arithmetics.add(100, 100));
console.log(Arithmetics.subtract(100, 7));
console.log(Arithmetics.multiply(5, 5));
console.log(Arithmetics.division(100, 5));

Output
100 + 100 = 200
100 - 7 = 93
5 * 5 = 25
100 / 5 = 20
Note: In the above example, functions are stored as a variable in an object.

 

These capabilities make JavaScript a powerful language, especially for functional programming.

1. Assigning a Function to a Variable
You can assign a function to a variable, making the function accessible via the variable name.


const greetMessage = function() {
    console.log("Hello, Prakash. Welcome to GeeksForGeeks!");
};

greetMessage(); // Output: Hello, Prakash. Welcome to GeeksForGeeks!

Output
Hello, Prakash. Welcome to GeeksForGeeks!

Here, greetMessage is a variable that holds a function. When you call greetMessage(), it executes the function.

2. Passing a Function as an Argument to Another Function
You can pass a function as an argument to another function, which can then execute it or use it in some way.


function wrapperFunction() {
    return "Welcome to GeeksForGeeks!";
}

function greetMessage(wrapper, name) {
    const message = wrapper();
    console.log(`${name}, ${message}`);
}

greetMessage(wrapperFunction, "Prakash"); // Output: Prakash, Welcome to GeeksForGeeks!

Output
Prakash, Welcome to GeeksForGeeks!
In this example, wrapperFunction is passed as an argument to greetMessage. Notice that we pass the reference of the function
(wrapperFunction) without parentheses, meaning the function is not executed immediately. Inside greetMessage, we call wrapper() 
to execute the function.

3. Returning a Function from Another Function
Functions can also return other functions. This feature is often used in functional programming.


function greetMessage() {
    return function() {
        console.log("Prakash, Welcome to GeeksForGeeks!");
    };
}

const output = greetMessage();
output(); // Output: Prakash, Welcome to GeeksForGeeks!

Output
Prakash, Welcome to GeeksForGeeks!
In this example, greetMessage returns another function. When we call greetMessage(), it returns the inner function, which we then store 
in the output variable. Finally, we call output() to execute the returned function.

Alternatively, you can also call the returned function directly:

greetMessage()(); // Output: Prakash, Welcome to GeeksForGeeks!
Here, greetMessage() is called first, which returns the inner function, and then the returned function is immediately executed with the
second pair of parentheses.

Why Are First-Class Functions Important?
First-class functions are the foundation of many powerful programming patterns in JavaScript, such as:

Callbacks: Functions passed as arguments to be executed later.
Closures: Functions that capture and remember their lexical environment.
Higher-Order Functions: Functions that return other functions or take functions as arguments.
Understanding first-class functions will make it easier to grasp these advanced concepts and write more flexible and reusable code.




HIGHER ORDER FUNCTION
---------------------
A Higher-Order function is a function that receives a function as an argument or returns function as output OR does both. 

1. Basic Example of Higher-Order Functions

Let's start with a basic example where a function accepts another function as an argument:

function wrapper() {
    return "Welcome to GFG";
}

function greetMessage(wrapper, name) {
    console.log(`${name}, ${wrapper()}`);
}

greetMessage(wrapper, "Prakash"); // Output: Prakash, Welcome to GFG
In this example, greetMessage is a higher-order function because it accepts wrapper, another function, as an argument. The wrapper 
function is called within greetMessage, allowing us to dynamically insert different messages.

2. Returning Functions from a Function

Higher-order functions can also return another function. Let's look at an example:

function displayMessage() {
    return function() {
        console.log("Hello from the inner function");
    };
}

const output = displayMessage();
output(); // Output: Hello from the inner function
Here, displayMessage is a higher-order function because it returns another function. When displayMessage is called, it returns the
inner function, which is then assigned to output. We can then call output() to execute the returned function.

3. Combining Both Concepts

Now, let's combine both concepts by writing a function that both accepts and returns functions:

function calculatePower(power) {
    return function(number) {
        return Math.pow(number, power);
    };
}

const square = calculatePower(2);
const cube = calculatePower(3);

console.log(square(4)); // Output: 16
console.log(cube(3)); // Output: 27
In this example, calculatePower is a higher-order function that returns a new function tailored to the specific power you want to apply.
square and cube are both functions generated by calculatePower, each configured to raise numbers to the second and third power,
respectively.

4. Applying Higher-Order Functions to Arrays

Higher-order functions are particularly useful when working with arrays in JavaScript, especially with methods like map, filter, and 
reduce.

Example: Using HOF with Array
Let's say you have an array of numbers, and you want to create a higher-order function to calculate different powers of the numbers in
the array.


function calculatePower(wrapper, arr) {
    const tempArr = [];
    for (let number of arr) {
        tempArr.push(wrapper(number));
    }
    return tempArr;
}

function square(number) {
    return number ** 2;
}

function cube(number) {
    return number ** 3;
}

const arr = [1, 2, 3, 4, 5];

const squaredNumbers = calculatePower(square, arr);
console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]

const cubedNumbers = calculatePower(cube, arr);
console.log(cubedNumbers); // Output: [1, 8, 27, 64, 125]
Here, calculatePower is a higher-order function that takes a function (wrapper) and an array as arguments. The wrapper function
(which can be square, cube, or any other function) is applied to each element in the array.

Summary:
Higher-order functions are a powerful feature in JavaScript that allows for more abstract, reusable, and flexible code. They are
foundational in functional programming and are commonly used in array methods like map, filter, and reduce.



MAP(),REDUCE() & FILTER() METHODS
---------------------------------
Note: These methods use higher order functions. It take function as argument and return an array.

The map(), reduce() and filter() are array functions that transform the array according to the applied function and return the updated
array. They are used to write simple, short and clean codes for modifying an array instead of using the loops.

map() method: It applies a given function on all the elements of the array and returns the updated array. It is the simpler and shorter
code instead of a loop. The map is similar to the following code: 

arr = new Array(1, 2, 3, 6, 5, 4);
for(let i = 0; i < 6; i++) {
    arr[i] *= 3;
}
console.log(arr);

Output
[ 3, 6, 9, 18, 15, 12 ]
 

Syntax:
array.map(function_to_be_applied)
array.map(function (args) {
    // code;
})
Example: 

function triple(n){
    return n*3;
}    
arr = new Array(1, 2, 3, 6, 5, 4);

var new_arr = arr.map(triple)
console.log(new_arr);

Output
[ 3, 6, 9, 18, 15, 12 ]
 

reduce() method: It reduces all the elements of the array to a single value by repeatedly applying a function. It is an alternative of 
using a loop and updating the result for every scanned element. Reduce can be used in place of the following code: 

arr = new Array(1, 2, 3, 6, 5, 4);
result = 1
for(let i = 0; i < 6; i++) {
    result = result * arr[i];
}
console.log(result);

Output
720
Syntax: 
array.reduce(function_to_be_applied)
array.reduce(function (args) {
    // code;
})
Example: 

function product(a, b){
    return a * b;
}
arr = new Array(1, 2, 3, 6, 5, 4);

var product_of_arr = arr.reduce(product)
console.log(product_of_arr)

Output
720
 

filter() method: It filters the elements of the array that return false for the applied condition and returns the array which contains 
elements that satisfy the applied condition. It is a simpler and shorter code instead of the below code using a loop: 

arr = new Array(1, 2, 3, 6, 5, 4);
new_arr = []
for(let i = 0; i < 6; i++) {
    if(arr[i] % 2 == 0) {
         new_arr.push(arr[i]);           
    }
}
console.log(new_arr);

Output
[ 2, 6, 4 ]
 

Syntax: 
array.filter(function_to_be_applied)
array.filter(function (args) {
    // condition;
})
Example: 

arr = new Array(1, 2, 3, 6, 5, 4);
var new_arr = arr.filter(function (x){
    return x % 2==0;
});

console.log(new_arr)

Output
[ 2, 6, 4 ]


ARUMENT OBJECT IN  NON ARROW FUNCTIONS
--------------------------------------
Note : It will not work in arrow functions

All the regular functions instead of Arrow functions have a special Object called Arguments Object that contains all the arguments 
passed to a function. It is an array Like Object present locally inside a function and it contains all the arguments passed to a 
function.

In javascript, if we pass more arguments than the specified parameters it won't give us an error. let's try to understand this with an 
example -
 
function calculateTotal(a,b){
 return a + b;
}

const total = calculateTotal(3,4,5,6,7,8,9);
console.log(total);

Output
7

As the output is 7 so it is true that it is not giving us an error but what is happening with the other arguments passed in a function 
call.
here is the argument object that comes into play. It stores all the arguments provided to it . Remember it is not a usual Object but 
an array-like Object. So we have a limit over the operations that we can perform over this arguments Object.

 
function calculateTotal(a,b){
 console.log(arguments);
}

calculateTotal(3,4,5,6,7,8,9);

Output
[Arguments] { '0': 3, '1': 4, '2': 5, '3': 6, '4': 7, '5': 8, '6': 9 }
so it looks like an array-like Object with key-value pairs.we can perform indexing over this objects.
if we want to change the value of a particular index we can do so as well

 


function calculateTotal(a,b){
 arguments[0]= 9;
 console.log(arguments);
}

calculateTotal(3,4,5,6,7,8,9);

Output
[Arguments] { '0': 9, '1': 4, '2': 5, '3': 6, '4': 7, '5': 8, '6': 9 }
 

You can see the value at index 0 is changed to 9.

We also have some caveats in this argument Object.
we can use the length method over this but we cannot use methods like map, filter, reduce that we use on normal Arrays.

So the solution to this problem is to convert the arguments object into an array so that we can use all the methods that are generally
available for arrays.


function calculateTotal(a,b){
 const arr1 = [...arguments];
 console.log(arr1);
 console.log(arguments);
}

calculateTotal(3,4,5,6,7,8,9);

Output
[
  3, 4, 5, 6,
  7, 8, 9
]
[Arguments] { '0': 3, '1': 4, '2': 5, '3': 6, '4': 7, '5': 8, '6': 9 }
 

Lets see what happens to the argument object when we have a Default parameter in our function :
 


function hello(a = 10){
 console.log(a); // line2
 console.log(arguments); //line3
 arguments[0] = 9;   // line4
 console.log(arguments);   //line5
 console.log(a);  //line6
}

hello(4);

Output
4
[Arguments] { '0': 4 }
[Arguments] { '0': 9 }
4
 

In case of default Parameter

Here in line 2 when the value of a is 4 as this was the argument passed to the hello function when it was called so the default value of
a is changed to 4 from 10. 
Now when argument object value at zero index was changed to 9 .Will it going to change the value of a as well? 
No. Changing the argument object won't change the value of 'a'. The value of 'a' will be the initial value that was passed through the
first call of the hello(4) method.


REST PARAMETER
--------------
The rest parameter is very similar to arguments Objects but it has some subtle differences. Let us try to understand it with the help of
an example.


function calculateTotal(a,b,...rest){
console.log(a);
console.log(b);
console.log(rest);
}

calculateTotal(2,3,4,5,7,8,9,11.16);
 


Output:
2
3
[ 4, 5, 7, 8, 9, 11.16 ]
 

So basically rest parameter collects all the remaining arguments and forms an array containing all of them as the name suggests rest 
parameter.

The most important Point to remember about the rest parameter is that it should always be used as the last parameter of the function 
otherwise there will be a syntax error.

The rest parameter is valuable when you are unsure about the number of arguments a function will have. It collects all these arguments
into an array, allowing you to perform various manipulations to achieve the desired results using that array.


SCOPE OF VARIABLES IN JAVASCRIPT
--------------------------------
Consider You are sitting in a room. How far can you see?


You can see only inside the room because that is where your vision can go and is limited to see inside those walls of the room.
Similarly, Scope in Programming is where can a variable be accessed in the environment where it is declared that is the visibility where
the variable can be used.


We generally have three types of scope 
1) Global Scope
2) Local Scope 
3) Block Scope 
 


Example of Global Variable: 


var x = 6 ; //Global Scope 

function hello(){
 
 console.log(x);

}

hello();

Output
6
 

 

Variable x is written in the top-level code so it is global scope and javaScript has this concept that even inside a hello function x is
not declared but it is still able to console the value of x from inside the function as the variable x is global Scope and this is how
 it works in Javascript.

Example Of Local Variable
 


var x = 6 ; //Global Scope 

function hello(){
 var y = 17; // Local Scope
 console.log(x);
 console.log(y);
}

hello();

Output
6
17
 

Inside Function hello(), variable y is local Scope as it can only be accessed within the function, if you try to access it outside the
function it will show a syntax error that y is not declared.
Even if We use let and const variable declaration, Global and Local variable concepts will work the same way.

Let us Now Understand About the type of Scope 
Global Scope - visibility all over the javascript Code 
Block Scope  - visibility only inside a piece of code generally wrapped by curly braces 

A block in programming is generally a way to wrap multiple lines of code to define that they work in series and we use { } brackets to 
define a Block Scope Example - for loop functions and if Block.

let and const declared variables are Block Scope and variables declared with keyword var are either global scope or function Scoped.
Consider this  Example 
 


{
 let a = 10 ;
 let b = 20 ;
}

console.log(a);
console.log(b);

If we try to compile this code it will throw us an error as a and b are let declarations so they are only block Scope .lets see what
happens when we try the same code with var declared variable.
 


{
 var a = 10 ;
 var b = 20 ;
}

console.log(a);
console.log(b);

Output
10
20
If we try to do the same with var declared variable it will give us the output as 
10
20
because var is either Global scope or Local Scope.



What if we try to use a var declared variable inside a function ?

In that case, they will act as a local variable and can only be accessed from inside the function. Example


function hello() {
 var a = 10 ;
 var b = 20 ;
}

console.log(a);
console.log(b);

 

This code will give us an error if we try to compile it because no matter if var declaration is used since a and b are declared inside
the function they will act as a local variable containing the scope only within the function.

So to summarize variables declared with var have Global Scope and variables declared with let and const have block Scope.
When a variable is declared with var keyword inside an if block it has a global scope but when it is declared inside a function it 
becomes a local variable of that function and cannot be accessed outside that function.
Variable declared with let and const always have block Scope. 


SCOPE CHAIN IN JAVASCRIPT
-----------------------------------
In JavaScript, the scope chain refers to the hierarchical order in which the runtime looks up variables and functions in the current 
execution context.

 

When a function is executed, a new execution context is created, which has its own variable environment. This environment includes all
the variables and functions declared inside the function, as well as any variables declared in outer scopes that the function has access
to.

The scope chain is created by linking together all the variable environments of the current execution context and its parent contexts,
forming a chain. When the JavaScript engine looks up a variable or function, it first checks the current execution context's variable 
environment. If the variable or function is not found there, it then moves up the scope chain to the parent context's variable
environment, and so on, until it either finds the variable or function or reaches the global object (i.e., the window object in a web
browser).

This mechanism allows functions to access variables declared in their outer scopes, a feature is known as lexical scoping. It also helps
prevent naming collisions by ensuring that variables with the same name declared in different scopes don't interfere with each other.
 


let a = 10;
function x(){
  let b = 20 ;
  console.log({ a });
  function y(){
    let c = 30;
    console.log({ b });
    function z(){
     console.log({ c });
    }
    z();
  }
  y();  
}
x();

Output
{ a: 10 }
{ b: 20 }
{ c: 30 }
 

 

Before Understanding the Output,it is important to remember that the function created inside a function can only be called within its 
parent Scope. That is function z can only be called from within the function y as function y acts as its parent Scope and where the 
function is physically created.


Coming to the output part -


When x() is invoked and we reach console.log(a), the js compiler first looks in the local scope of the function x that whether variable
a is present there. Since it cannot find variable a within its own local scope, it moves up in the scope chain that is it will look in
the global scope of the program whether variable a is present there or not. Since a is found in the global scope it will print the 
value of a.
Similarly when function y is invoked and we reach the line of console.log(b); it will first try to find the value of b, in the local 
Scope once the value is not found it will move up to its parent scope function that function x() since function x contains variable b.
The value of b, will be printed. Similarly, for the case of function invocation of z(), if variable c is not present in the local scope
of function z, it will move up in its parent scope and once it finds the variable c in its parent scope, it will print the value of 
variable c as well.

It is important to note that the js compiler will keep looking up the ints parent scope and follows the hierarchy up till the global
scope(top-level code).In case it does not find the variable in the topmost global scope as well it will then throw an error.

The example below will clear the concept in a better way-
 


let a = 10;
let b = 20 ;
let c = 30;
function x(){
  console.log({ a });
  function y(){
    console.log({ b });
    function z(){
     console.log({ c });
    }
    z();
  }
  y();  
}
x();

Output
{ a: 10 }
{ b: 20 }
{ c: 30 }

If we shift the declaration of variables a,b,c to the topmost scope,we still get the same result because the compiler will keep looking
in the parent of the parent hierarchy until it found the variable in the top-most scope i.e Global Scope of the program.




Lexical Environment and Scope Chain:

The lexical environment is a theoretical concept that refers to the environment in which code is written and executed. It includes:

1. Environment Record: This stores all variable and function declarations.
2. Reference to Outer Lexical Environment: This connects to the parent lexical environment, forming a chain back to the global environment.
The scope chain is made possible by this lexical environment. Each function and block of code has its own lexical environment, which 
links to its parent environment, creating the chain.

Visualization with Execution Contexts:

To better understand the scope chain, let’s visualize the execution context and lexical environments:

Global Execution Context: Contains a = 3 and function x.
Function x Execution Context: Contains b = 5 and function y. References the global lexical environment.
Function y Execution Context: Contains c = 7 and function z. References the lexical environment of x.
Function z Execution Context: Has access to a, b, and c through its scope chain.
Why Scope Chains Are Important


Understanding scope chains is crucial because it helps in:

Debugging: Knowing how and where JavaScript looks for variables helps in diagnosing issues.
Memory Management: Avoiding unnecessary global variables reduces memory leaks.
Optimization: Writing code that leverages local scopes and minimizes reliance on the global scope improves performance.



So Scope chain is Possible Due to something called a lexical Environment .
A lexical environment in JavaScript refers to the set of variables, functions, and other data structures that are available in a 
particular section of code during its execution. It consists of two parts: a variable environment and a reference to the outer lexical 
environment

Whenever a function executes it has 2 things.
1)Variable Environment
2)Reference to Outer Lexical Environment that is the Parent's lexical Environment.

So if we analyze the above code 
when x() is invoked its variable environment will have a variable b and function y but it will also have an access to its outer lexical 
Environment which is the global lexical environment in this case so since function x does not have a variable a declared inside it, it
is still able to access a which is present in its outer lexical Environment. This is because every function has access to its outer 
lexical Environment as well.

The above explanation is valid for the function invocation of y() as well since function y() only has variable c and function z() in
its variable environment, it is still able to console.log(b) because it has an excess to its outer lexical environment which is function
x() in case of function y().

The above explanation is valid for the function invocation of function z() , since function z() has only access to variable d in its 
variable environment it is still able to access variable c and print its value which is present or declared in function y, the same 
explanation holds true that it also has a reference to its parent environment as well which is function y().


Conclusion:

The scope chain is a fundamental concept in JavaScript that determines how variables are resolved in different execution contexts. 
By understanding how scope chains work and the role of lexical environments, you can write more efficient and bug-free code. This 
concept also sets the stage for more advanced topics like closures and higher-order functions, which build upon the idea of scope 
chains




RECURSION 
---------
Recursion is one of the most powerful and elegant techniques in programming. At its core, recursion is when a function calls itself in
order to solve a problem. While it may seem complex at first, once understood, it can be an invaluable tool in your programming toolkit.

What is Recursion?
Recursion is a programming concept where a function calls itself in order to break down a problem into smaller, more manageable parts. 
The key idea is to solve a small piece of the problem and then use the solution of that small piece to solve the next piece, and so on,
until the entire problem is solved.


Recursion is the way of writing a piece of code in an elegant manner by calling the same function from within that function.
the best way to understand the recursion is to use the dry run and pictorial representation of each step.
in this article we are going to understand recursion using two examples 

1)Sum of elements of an array using recursion
2)Factorial of a number using recursion
 


Sum of elements of an array using recursion
 
 
// JavaScript program to find sum of array
// elements using recursion.
 
// Return sum of elements in A[0..N-1]
// using recursion.
function findSum(A, N) {
    if (N <= 0)
        return 0;
    return (findSum(A, N - 1) + A[N - 1]);
}
 
// Driver code
 
let A = [1, 2, 3, 4, 5];
let N = A.length;
const total = findSum(A,N);
console.log(total);

Output
15

Factorial of a number using recursion
 
// Javascript to find factorial
// of given number  
// function to find factorial
// of given number
function factorial(n) {
  if (n == 0) return 1;
  return n * factorial(n - 1);
}
  
// Driver Code
let num = 5;
const fact = factorial(num);
console.log(fact);

Output
120


Key Points to Remember:

Base Case: A condition that stops the recursion. Without it, the recursion would run indefinitely.
Recursive Case: The part of the function where the function calls itself with a smaller or simpler problem.
Stack Overflow: Recursion relies on the function call stack. If the recursion depth is too large, it can lead to a stack overflow error.

When to Use Recursion:
Recursion is particularly useful for problems that can naturally be divided into similar subproblems, such as:

Calculating factorials
Summing numbers
Traversing tree or graph structures
Solving puzzles like the Tower of Hanoi
Implementing algorithms like quicksort or mergesort

Conclusion:
Recursion is a powerful technique that, when understood, can make certain problems easier to solve and your code more elegant. However, 
it requires careful handling, particularly ensuring that you have a proper base case to prevent infinite recursion. Practice with 
different problems, and you'll soon appreciate the beauty and power of recursion in programming.



CLOSURE IN JAVASCRIPT
---------------------
A closure is the combination of the function bundled together with reference to its lexical environments is known as closure.
In other words - A closure is a function that remembers its outer variable and can access them.

Look at the example below.
 


function x(){
  let a = 10 ;
  function y(){
   let b = 20;
   console.log(a);
    function z(){
     console.log(b);
    }
   z();
  } 
 y();
}
x();

Output
10
20
Here if you see function z() does not have variable b in its scope so it looks up in the hierarchy for the value of b and since it has
reference to its outer lexical environment it is able to print the value of b .hence this function forms a closure with its outer 
environment and can access the variable of its outer environment as well.

Now the concept of closures is quite similar to that we learned in the Scope and Scope chain article but there is more to closures.
let's try to understand this example
 


function x(){
  let a = 10 ;
  return function y(){
   console.log(a);
  } 
}
const z = x();
z();

Output
10
Technically in the above example when the code execution for function x() is finished, it is cleared from memory i.e once the function
has finished executing the functional execution context or the Global Execution Context is deleted from the memory so all the lexical
environment variables are also gone. But we can see that if we return the function in a variable and call it using that variable the 
value of a is still printed in the correct way although the execution of function x() has already been finished and memory for
function x() that was holding variable a in itself is also gone. So how does variable a is still accessible .this is where the second 
definition of closures comes into effect.


" A closure is a function that remembers its outer variable and can access them ."
function y closes over the function x(), the memory used for the execution of function x() is gone but the scope chain that function y()
has is still intact .this is the reason that we are able to access variable a  through function z() even after the memory for 
function x() is gone.
There are certain caveats in closures as well.


Example-1 


function x(){
 let a = 10;
 return function y(){
  console.log(a);
  let a;
 }
}
const z = x();
z();

If You try to run this code the output will not be 10 but it will give an error saying cannot access a before initialization.
The reason is that although function y() is forming the closure with function x() if we recall the concept of hoisting let and const
declarations are hoisted but they exist in the temporal dead zone so they cannot be accessed before initialization and compiler first
try to access the local variable of function y() if it does not exist then it goes to the parent scope. Similarly inside function y if
we change the let declaration with var keyword then the output will be undefined, the reason being the same -:
 


function x(){
 var a = 10;
 return function y(){
  console.log(a);
  var a;
 }
}
const z = x();
z();

Output
undefined



Closures
--------
When you start learning programming, certain concepts can seem daunting, especially when they appear under "advanced topics." One such
concept in JavaScript is closures. Despite their reputation for being difficult, closures are fundamental and, once understood, become
a powerful tool in your coding arsenal. This guide will demystify closures, explaining what they are, how they work, and why they are
so important.

What is a Closure?
A closure is essentially a function bundled together with its surrounding state (the lexical environment). In simpler terms, a closure 
is a function that remembers the variables from the place where it was defined, even after that place is no longer accessible.

Definition:
Technical Definition: A closure is a combination of a function and its lexical environment within which that function was declared.
Simplified Definition: A closure is a function that can access and "remember" variables from its outer function even after the outer
function has finished executing.


How Does a Closure Work?
To understand closures, it’s important to grasp the concepts of scope, scope chain, and lexical environment. Let's dive into an example
to see closures in action.

Example: Basic Closure

function outerFunction() {
    let outerVariable = 10;

    function innerFunction() {
        console.log(outerVariable); // Accesses outerVariable
    }

    return innerFunction;
}

const myClosure = outerFunction(); // Returns the innerFunction
myClosure(); // Executes innerFunction, logs 10

Output
10

Explanation: 

outerFunction creates a variable outerVariable and defines innerFunction.
innerFunction is returned and assigned to myClosure.
Even after outerFunction has finished executing, myClosure (which is innerFunction) still has access to outerVariable because of the
closure.
This example illustrates the key feature of closures: retaining access to the scope of the outer function even after the outer function
has finished execution.

Closures in Action:
Example: Maintaining State with Closures

function counter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

const increment = counter();
console.log(increment()); // 1
console.log(increment()); // 2
console.log(increment()); // 3

Output
1
2
3

Here, the counter function creates a count variable and returns an inner function that increments and returns count. Each time increment
is called, it increases the value of count, showing that the inner function remembers the state of count across multiple invocations.
Example-1 

Why Are Closures Important?
Closures are powerful because they allow for:

Data Encapsulation: Variables within a closure are not accessible from the outside, creating a private scope.
Persistent State: Functions can retain state between executions, which is useful in many scenarios like creating counters, managing event
listeners, or even building modules.

Higher-Order Functions: Closures are fundamental to understanding concepts like callbacks, functional programming, and higher-order
functions.

Common Pitfalls and Considerations
While closures are powerful, they can also introduce complexity, especially when dealing with variables that change over time. Consider
the following example:


function createFunctions() {
    let functions = [];
    for (var i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i);
        });
    }
    return functions;
}

const funcs = createFunctions();
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3

Output
3
3
3

What’s Happening?
 

All functions returned by createFunctions log the value 3. This happens because var is function-scoped, and by the time the functions
are invoked, the loop has completed, leaving i with the value 3.

Solution:
Using let instead of var:


function createFunctions() {
    let functions = [];
    for (let i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i);
        });
    }
    return functions;
}

const funcs = createFunctions();
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2

Output
0
1
2
Now, each function correctly remembers its own i value due to block-scoping provided by let.

Conclusion
Closures are a foundational concept in JavaScript that allow functions to maintain access to variables even after the outer function has
finished execution. By mastering closures, you gain the ability to write more robust, modular, and efficient code.

Whether you're creating private variables, persistent states, or sophisticated functional programming patterns, closures are an
indispensable tool. With practice, the concept of closures will become second nature, opening up new possibilities in your JavaScript 
development journey.









                                        DOM (Document Object Model)
                                        ---------------------------
The Document Object Model (DOM) is a programming interface for HTML(Hypertext Markup Language) and XML(Extensible markup language) 
documents. It defines the logical structure of documents and the way a document is accessed and manipulated.

Note: It is called a Logical structure because DOM doesn’t specify any relationship between objects. 

DOM is a way to represent the webpage in a structured hierarchical way so that it will become easier for programmers and users to glide
through the document. With DOM, we can easily access and manipulate tags, IDs, classes, Attributes, or Elements of HTML using commands
or methods provided by the Document object. Using DOM, the JavaScript gets access to HTML as well as CSS of the web page and can also
add behavior to the HTML elements. So basically Document Object Model is an API that represents and interacts with HTML or XML documents.

Why DOM is required?

HTML is used to structure the web pages and JavaScript is used to add behavior to our web pages. When an HTML file is loaded into the
browser, the JavaScript can not understand the HTML document directly. So, a corresponding document is created(DOM). DOM is basically
the representation of the same HTML document but in a different format with the use of objects. JavaScript interprets DOM easily i.e.
JavaScript can not understand the tags(<h1>H</h1>) in HTML document but can understand object h1 in DOM. Now, JavaScript can access
each of the objects (h1, p, etc) by using different functions.

Structure of DOM: DOM can be thought of as a Tree or Forest(more than one tree). The term structure model is sometimes used to describe
the tree-like representation of a document.  Each branch of the tree ends in a node, and each node contains objects  Event listeners
can be added to nodes and triggered on an occurrence of a given event. One important property of DOM structure models is structural
isomorphism: if any two DOM implementations are used to create a representation of the same document, they will create the same structure
model, with precisely the same objects and relationships.

Why called an Object Model?
Documents are modeled using objects, and the model includes not only the structure of a document but also the behavior of a document and 
the objects of which it is composed like tag elements with attributes in HTML.


How and When is the DOM Created?
The creation of the DOM follows a specific process during the page load:

HTML Loading: The browser first loads the HTML document.
HTML Parsing: As the browser loads the HTML, it begins parsing it from top to bottom.
DOM Tree Creation: During parsing, the browser constructs the DOM tree. This tree represents the hierarchical structure of the HTML
document.




Properties of DOM: Let’s see the properties of the document object that can be accessed and modified by the document object.


Properties of DOM
 

Window Object: Window Object is object of the browser which is always at top of the hierarchy.  It is like an API that is used to set
and access all the properties and methods of the browser. It is automatically created by the browser.
Document object: When an HTML document is loaded into a window, it becomes a document object. The ‘document’ object has various
properties that refer to other objects which allow access to and modification of the content of the web page. If there is a need to
access any element in an HTML page, we always start with accessing the ‘document’ object. Document object is property of window object.
Form Object: It is represented by form tags.
Link Object: It is represented by link tags.
Anchor Object: It is represented by a href tags.
Form Control Elements: Form can have many control elements such as text fields, buttons, radio buttons, checkboxes, etc.





GFG Note About DOM:

The Document Object Model, or DOM, is a critical concept in web development. It serves as the interface between HTML documents and 
JavaScript, enabling scripts to dynamically access and update the content, structure, and style of a document.

What is the DOM?
The DOM stands for Document Object Model. It represents the HTML structure of a webpage in a tree-like format, where each node
corresponds to an element in the document. This structure allows programming languages like JavaScript to interact with the document
in a structured way, manipulating elements, attributes, and content.

How and When is the DOM Created?
The creation of the DOM follows a specific process during the page load:

HTML Loading: The browser first loads the HTML document.
HTML Parsing: As the browser loads the HTML, it begins parsing it from top to bottom.
DOM Tree Creation: During parsing, the browser constructs the DOM tree. This tree represents the hierarchical structure of the HTML
document.

Structure of the DOM Tree
The DOM tree starts with the HTML element as the root, which branches out into child nodes such as HEAD and BODY. These child nodes
further branch out into their own child nodes, forming a tree structure.


Properties of DOM

 HTML
├── HEAD
│   ├── META
│   ├── TITLE
│   └── LINK
└── BODY
    ├── H1
    ├── DIV
    │   ├── P
    │   ├── BUTTON
    │   └── A
    └── SECTION
        ├── ARTICLE
        │   ├── P
        │   └── SPAN

Window Object: Window Object is object of the browser which is always at top of the hierarchy.  It is like an API that is used to set
and access all the properties and methods of the browser. It is automatically created by the browser.
Document object: When an HTML document is loaded into a window, it becomes a document object. The ‘document’ object has various 
properties that refer to other objects which allow access to and modification of the content of the web page. If there is a need to
access any element in an HTML page, we always start with accessing the ‘document’ object. Document object is property of window object.
Form Object: It is represented by form tags.
Link Object: It is represented by link tags.
Anchor Object: It is represented by a href tags.
Form Control Elements: Form can have many control elements such as text fields, buttons, radio buttons, checkboxes, etc.


Why is the DOM Tree Created?
The DOM tree is created to allow JavaScript to interact with the HTML document. Since JavaScript cannot directly understand HTML, the
DOM provides a structured model that JavaScript can manipulate. This allows for tasks like searching for elements, adding event 
listeners, modifying content, and updating styles.

Manipulating the DOM
JavaScript interacts with the DOM using various methods:

Searching for Elements: Methods like document.getElementById(), document.getElementsByClassName(), and document.querySelector() allow 
you to select elements in the DOM.
Modifying Elements: Once an element is selected, its content, attributes, and styles can be changed using properties and methods like 
innerHTML, setAttribute(), and style.
Event Handling: Event listeners can be added to DOM elements to respond to user interactions, such as clicks or key presses.

The Role of DOM in Webpage Rendering
The DOM is crucial in rendering a webpage. The process is as follows:

HTML Loading and Parsing: The browser loads and parses the HTML to create the DOM.
CSS Loading and Parsing: Concurrently, the browser loads and parses the CSS, creating the CSS Object Model (CSSOM).
Render Tree Creation: The DOM and CSSOM are combined to create the render tree, which represents the document's content and styles.
Layout and Painting: The render tree is used to calculate the layout, determining the position and size of each element. Finally, the 
browser paints the elements onto the screen.


Conclusion
Understanding the DOM is fundamental to web development. It is the foundation upon which JavaScript interacts with a webpage, allowing
for dynamic content manipulation, user interaction, and responsive design. By understanding how the DOM works, you can harness the full
power of JavaScript to create interactive and engaging web applications.


HTML DOM getElementByID() Method 
--------------------------------
The getElementById() method returns the elements that have given an ID which is passed to the function. This function is a widely used
HTML DOM method in web designing to change the value of any particular element or get a particular element. If the passed ID to the
function does not exist then it returns null. The element is required to have a unique id, in order to get access to that specific
element quickly, & also that particular id should only be used once in the entire document.

Syntax:
document.getElementById( 'element_ID' );

Parameter: This function accepts single parameter element_ID which is used to hold the ID of the element.

Return Value: It returns the object of the given ID. If no element exists with the given ID then it returns null.

Example 1: This example describes the getElementById() method where element_id is used to change the color of the text on clicking the 
button.


<!DOCTYPE html>
<html>
  
<head>
    <title>
        DOM getElementById() Method
    </title>
  
    <script>
  
        // Function to change the color of element
        function geeks() {
            var demo = document.getElementById("geeks");
            demo.style.color = "green";
        }
    </script>
</head>
  
<body style="text-align:center">
    <h1 id="geeks">GeeksforGeeks</h1>
    <h2>DOM getElementById() Method</h2>
  
    <!-- Click on the button to change color -->
    <input type="button" 
           onclick="geeks()" 
           value="Click here to change color" />
</body>
  
</html>
 

Example 2: This example describes the getElementById() method where the element_id is used to change the content on clicking the button.


<!DOCTYPE html>
<html>
  
<head>
    <title>
        DOM getElementById() Method
    </title>
  
    <script>
  
        // Function to change content of element
        function geeks() {
            var demo = document.getElementById("geeks");
            demo.innerHTML = "Welcome to GeeksforGeeks!";
        }
    </script>
</head>
  
<body style="text-align:center">
    <h1>GeeksforGeeks</h1>
    <h2>DOM getElementById() Method</h2>
    <h3 id="geeks">Hello Geeks!</h3>
  
    <!-- Click here to change content -->
    <input type="button" 
           onclick="geeks()" 
           value="Click here to change content" />
</body>
  
</html>
 

DOM querySelectorAll() Method
-----------------------------
The querySelectorAll() method in HTML is used to return a collection of an element’s child elements that match a specified CSS selector(s),
as a static NodeList object. The NodeList object represents a collection of nodes. The nodes can be accessed by index numbers. The index
starts at 0. 
Note: If we want to apply CSS property to all the child nodes that match the specified selector, then we can just iterate through all
nodes and apply that particular property.

Syntax: 
element.querySelectorAll('selectors');

Selectors is the required field. It specifies one or more CSS selectors to match the element.These selectors are used to select HTML
elements based on their id, classes, types, etc. 

In case of multiple selectors, comma is used to separate each selector.

Example: 

<!DOCTYPE html>
<html>
    <head>
        <title>DOM querySelectorAll() Method</title>
        <style>
            #geek {
              border: 1px solid black;
              margin: 5px;
            }
        </style>
    </head>
    <body style = "text-align: center;">
        <h1 style = "color: green;">GeeksforGeeks</h1>
        <h2>querySelectorAll() Method</h2>
        <div id="geek">
             
 
<p>This is paragraph 1.</p>
 
 
             
 
<p>This is paragraph 2.</p>
 
 
        </div>
        <button onclick="myFunction()">Try it</button>
        <script>
            function myFunction() {
                var x = document.getElementById("geek").querySelectorAll("p");
                var i;
                for (i = 0; i < x.length; i++) {
                x[i].style.backgroundColor = "green";
                x[i].style.color = "white";
                }
            }
        </script>
    </body>
</html>


Event Listners
--------------
An event is an important part of JavaScript.A web page respond according to an event occurred. Some events are user generated and some 
are generated by API’s. An event listener is a procedure in JavaScript that waits for an event to occur. The simple example of an event
is a user clicking the mouse or pressing a key on the keyboard.

The addEventListener() is an inbuilt function in JavaScript which takes the event to listen for, and a second argument to be called
whenever the described event gets fired. Any number of event handlers can be added to a single element without overwriting existing 
event handlers. 

Syntax:  element.addEventListener(event, listener, useCapture);

Parameters: 

event : event can be any valid JavaScript event.Events are used without “on” prefix like use “click” instead of “onclick” or “mousedown”
instead of “onmousedown”.

listener(handler function) : It can be a JavaScript function which respond to the event occur.

useCapture: It is an optional parameter used to control event propagation. A boolean value is passed where “true” denotes capturing 
phase and “false” denotes the bubbling phase.

JavaScript Code to show the working of addEventListener() method : 

code #1: 


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Listener Example</title>
</head>
<body>

<button id="myButton">Click me</button>
<p id="geek"></p>

<script>
// Get the button element by its ID
var button = document.getElementById("myButton");
var geek=document.getElementById("geek")

// Define the event handler function
function handleClick() {
//   alert("Button clicked!");
geek.innerHTML='<H1>GeeksforGeeks</H1>'
}

// Attach the event listener to the button
button.addEventListener("click", handleClick);

</script>

</body>
</html>


 

Output: Text appears when button is clicked
 

code #2: 
In this example two events “mouseover” and “mouseout” are added to the same element. If the text is hovered over then “mouseover” event
occur and RespondMouseOver function invoked, similarly for “mouseout” event RespondMouseOut function invoked. 


<!DOCTYPE html>
<html>
  
<body>
    <button id="clickIt">Click here</button>
  
    <p id="hoverPara">Hover over this Text !</p>
  
  
    <b id="effect"></b>
  
    <script>
        const x = document.getElementById("clickIt");
        const y = document.getElementById("hoverPara");
  
        x.addEventListener("click", RespondClick);
        y.addEventListener("mouseover", RespondMouseOver);
        y.addEventListener("mouseout", RespondMouseOut);
  
        function RespondMouseOver() {
            document.getElementById("effect").innerHTML +=
                       "MouseOver Event" + "<br>";
        }
  
        function RespondMouseOut() {
            document.getElementById("effect").innerHTML +=
                      "MouseOut Event" + "<br>";
        }
  
        function RespondClick() {
            document.getElementById("effect").innerHTML +=
                      "Click Event" + "<br>";
        }
    </script>
</body>
  
</html>


Output: Events logged on different interactions 


Event Bubbling
--------------
Event bubbling is a method of event propagation in the HTML DOM API when an event is in an element inside another element, and both elements have registered a handle to that event. It is a process that starts with the element that triggered the event and then bubbles up to the containing elements in the hierarchy. In event bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements.

Syntax: 

addEventListener(type, listener, useCapture)
type: Use to refer to the type of event.
listener: Function we want to call when the event of the specified type occurs.
userCapture: Boolean value. Boolean value indicates event phase. By Default useCapture is false. It means it is in the bubbling phase.
Example 1: This example shows the working of event bubbling in JavaScript.


<!DOCTYPE html>
<html>
 
<head>
    <title>
        Bubbling Event in Javascript
    </title>
</head>
 
<body>
 
    <h2>Bubbling Event in Javascript</h2>
 
    <div id="parent">
      <button>
          <h2>Parent</h2>
      </button>
      <button id="child">
           
<p>Child</p>
 
      </button>
    </div><br>
 
 
    <script>
        document.getElementById(
"child").addEventListener("click", function () {
            alert("You clicked the Child element!");
        }, false);
 
        document.getElementById(
"parent").addEventListener("click", function () {
            alert("You clicked the parent element!");
        }, false);
    </script>
 
</body>
 
</html>

From above example we understand that in bubbling the innermost element’s event is handled first and then the outer: the <p> element’s 
click event is handled first, then the <div> element’s click event.



Event Delegation
----------------
Event delegation in JavaScript is a powerful technique that allows you to manage events efficiently, especially when dealing with a large
number of similar elements, such as buttons or list items.

What is Event Delegation?
Event delegation is a technique where you add a single event listener to a parent element instead of adding multiple event listeners to
each child element. This takes advantage of event bubbling, where an event triggered on a child element propagates (or "bubbles up") 
to its parent elements. By placing the event listener on a common ancestor, you can capture events from all its children.

Problem Scenario
Let's say we have a group of buttons, and we want to change the color of a button when it's clicked. Instead of attaching a separate 
event listener to each button, we can attach one event listener to the parent element that contains all the buttons. This is especially
useful if we have a large number of buttons or if the buttons are dynamically added to the DOM.

Example Implementation
Consider the following HTML structure:

const customUI = document.createElement('ul');

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    newElement.addEventListener('click', () => {
        console.log('Responding')
    })
    customUI.appendChild(newElement);
}
The above code will associate the function with every <li> element that is shown in the below image. We are creating an <ul> element, 
attaching too many <li> elements, and attaching an event listener with a responding function to each paragraph as we create it.


 
Implementing the same functionalities with an alternate approach. In this approach, we will associate the same function with all event
listeners. We are creating too many responding functions (that all actually do the exact same thing). We could extract this function and
just reference the function instead of creating too many functions:

const customUI = document.createElement('ul');

function responding() {
    console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    newElement.addEventListener('click', responding)
    customUI.appendChild(newElement);
}
The functionality of the above code is shown below –


 
In the above approach, we still have too many event listeners pointing to the same function. Now implementing the same functionalities
using a single function and single event.

const customUI = document.createElement('ul');

function responding() {
    console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    customUI.appendChild(newElement);
}
customUI.addEventListener('click', responding)

Now there is a single event listener and a single responding function. In the above-shown method, we have improved the performance, but
we have lost access to individual <li> elements so to resolve this issue, we will use a technique called event delegation. 

The event object has a special property call .target which will help us in getting access to individual <li> elements with the help of
phases.

Steps:

<ul> element is clicked.
The event goes in the capturing phase.
It reaches the target (<li> in our case).
It switches to the bubbling phase.
When it hits the <ul> element, it runs the event listener.
Inside the listener function event.target is the element that was clicked.
Event.target provides us access to the <li> element that was clicked.
The .nodeName property of the .target allows us to identify a specific node. If our parent element contains more than one child element
then we can identify specific elements by using the .nodeName property.

const customUI = document.createElement('ul');

function responding(evt) {
    if (evt.target.nodeName === 'li')
        console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    customUI.appendChild(newElement);
}

customUI.addEventListener('click', responding);

How It Works:

Parent Element Selection: We first select the parent element (buttonContainer) that contains all the buttons.
Event Listener: We attach an event listener to this parent element that listens for click events.
Event Bubbling: When any button inside the buttonContainer is clicked, the event bubbles up to the parent element. The event.target
property is used to identify the specific child element (button) that was clicked.
Event Handling: Inside the event handler, we check if the clicked element is a button. If it is, we can proceed to perform actions 
based on the button's inner text (e.g., changing the button's background color).

Advantages of Event Delegation:

Efficiency: Instead of adding multiple event listeners to each child element, we only add one to the parent. This reduces memory usage
and enhances performance, especially when dealing with many elements.

Dynamic Content: If new buttons are added to the DOM dynamically, they will automatically be covered by the parent’s event listener, 
without the need to add additional listeners.

Maintainability: The code is easier to maintain since there’s only one event listener to manage, rather than many.

Conclusion:

Event delegation is a simple yet powerful technique that allows you to manage events efficiently in JavaScript. By understanding and
utilizing event bubbling and delegation, you can write cleaner, more efficient, and more maintainable code. This approach is particularly
useful when dealing with dynamic content or a large number of similar elements.

Whether you are building a simple web application or a complex dynamic interface, mastering event delegation will make your JavaScript
code more robust and easier to manage.



Creating HTML using Javascript
------------------------------
In this article, we will discuss how to create HTML elements using JavaScript.

The following HTML has been provided to us, and our task is to recreate the given card element using JavaScript.


<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Creating HTML Element with JS</title>
  <style>
    #parent-container {
      display: flex;
      flex-direction: row;
    }

    .card-container {
      width: 30%;
      display: flex;
      flex-direction: column;
      text-align: center;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
      margin: 10px;
      padding-bottom: 5px;
    }

    @media only screen and (max-width: 600px) {
      #parent-container {
        flex-direction: column;
      }
    }
  </style>
</head>

<body>
  <div id="parent-container">
    <div class="card-container">
      <img class="image" src="https://wttc.org/DesktopModules/MVC/NewsArticleList/images/141_20201013185512_Consumer%20Survey%20
      Finds%2070%20Percent%20of%20Travelers%20plan%20to%20Holiday%20in%202021.jpg" alt="travel-card" />
      <span>The journey of a thousand miles begins with a single
        step</span>
    </div>
  </div>

  <script src="index3.js"></script>
</body>

</html>
Output: Rendered HTML


To re-create the card, we would first fetch the parent-container, by using document.getElementById(), then we would use the document.
createElement method to create a new element and set the CSS classes for that element using the .classlist.add() method.

Then, we would create another element - the image element with correct alt text(using setAttribute) and the span with the text, and 
finally add child elements to parent elements using the .appendChild() method.


Check out the JS code enclosed in the script tag below -

<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Creating HTML Element with JS</title>

  <style>
    #parent-container {
      display: flex;
      flex-direction: row;
    }

    .card-container {
      width: 30%;
      display: flex;
      flex-direction: column;
      text-align: center;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
      margin: 10px;
      padding-bottom: 5px;
    }

    @media only screen and (max-width: 600px) {
      #parent-container {
        flex-direction: column;
      }
    }
  </style>
</head>

<body>
  <div id="parent-container">
    <div class="card-container">
      <img src="https://wttc.org/DesktopModules/MVC/NewsArticleList/images/141_20201013185512_Consumer%20Survey%20Finds%2070%20Percen
      t%20of%20Travelers%20plan%20to%20Holiday%20in%202021.jpg" alt="travel-card" />
      <span>The journey of a thousand miles begins with a single
        step</span>
    </div>
  </div>

  <script type="text/javascript">
    const parentContainer = document.getElementById("parent-container");
    
    const cardContainer = document.createElement("div");
    cardContainer.classList.add("card-container");
    
    const cardImage = document.createElement("img");
    cardImage.setAttribute("src", "https://wttc.org/DesktopModules/MVC/NewsArticleList/images/141_20201013185512_Consumer%20Survey%20
    Finds%2070%20Percent%20of%20Travelers%20plan%20to%20Holiday%20in%202021.jpg");
    cardImage.setAttribute('alt', "travel-card");
    
    const cardSpan = document.createElement("span");
    const text = document.createTextNode("The journey of a thousand miles begins with a single step");
    cardSpan.appendChild(text);
    
    cardContainer.appendChild(cardImage);
    cardContainer.appendChild(cardSpan);
    
    parentContainer.appendChild(cardContainer);
  </script>
</body>

</html>
Output:

New element made with JS identical to the one made with HTML


Async And Defer
---------------

In JavaScript, the async and defer attributes are used in the <script> tag to manage the loading and execution of external JavaScript
files. They both control how scripts are fetched and executed, helping to optimize web page performance by avoiding render-blocking 
behavior.

1. async Attribute
When to use: If you want the script to load asynchronously (without blocking the HTML parsing) and be executed as soon as it is
downloaded.

Behavior:
The script is downloaded in parallel with the HTML document.
The script executes immediately after it has finished downloading, without waiting for the HTML parsing to finish.

Order of execution: If there are multiple async scripts, they may not execute in the order they appear in the HTML. They will execute as
soon as each finishes downloading.

Example: <script src="example.js" async></script>


2. defer Attribute
When to use: If you want to ensure that scripts are executed after the HTML has been completely parsed and in the order they appear in 
the document.

Behavior:
The script is downloaded in parallel with the HTML parsing (like async), but it waits until the HTML is fully parsed before executing.

Order of execution: If there are multiple defer scripts, they will execute in the order they appear in the document.

Example: <script src="example.js" defer></script>

Key Differences:

Execution Timing:
async: Executes as soon as it finishes downloading, without waiting for HTML parsing.
defer: Waits for HTML parsing to complete before executing.

Execution Order:
async: No guaranteed order (executes as soon as each script is ready).
defer: Executes in the order they are listed in the HTML.


In summary:
Use async for independent scripts where execution order doesn't matter (e.g., third-party analytics).
Use defer for scripts that rely on the DOM or need to run in a specific order.

------------------------------------------------------------------------------------------------------------------------------------------


polyfills
---------

In the ever-evolving world of web development, ensuring that your code works seamlessly across all browsers is crucial. One challenge
developers often face is the lack of support for modern JavaScript features in older browsers. This is where polyfills come into play.


What is a Polyfill?
A polyfill is a piece of JavaScript code that enables modern functionalities on older browsers that do not natively support them. As 
JavaScript evolves, new methods and features are introduced, but not all browsers, especially older ones, support these updates. 
Polyfills serve as a fallback, allowing developers to implement these new features even in environments where they are not supported.

The Need for Polyfills
Web applications are expected to function flawlessly across different browsers and versions. However, with the rapid advancement of 
JavaScript, newer methods like map(), filter(), reduce(), and flatten() may not be supported in older browsers. Without polyfills, 
using these methods could lead to functionality issues for users on outdated browsers. Polyfills ensure that your code remains 
compatible and functional across all platforms.

Creating a Polyfill for the map() Method
-----------------------------------------
To understand how polyfills work, let's create a polyfill for the map() method. The map() method is used to apply a function to each 
element in an array, returning a new array with the results.

Step 1: Understanding the Prototype
In JavaScript, every object has a hidden property called a prototype. This prototype can reference other objects and contains methods
that are shared across all instances of that object. For example, array methods like map(), filter(), and reduce() are part of the 
Array.prototype, allowing them to be used by any array.

Step 2: Writing the Polyfill
To create our own version of the map() method, we first need to extend the Array.prototype with our custom method:


Array.prototype.myMap = function(callback) {
    let tempArray = [];
    for (let i = 0; i < this.length; i++) {
        tempArray.push(callback(this[i], i, this));
    }
    return tempArray;
};

Explanation of the Code:

Array.prototype.myMap: This extends the array prototype with a new method called myMap.
callback: The myMap method takes a callback function as an argument. This callback will be applied to each element in the array.
this: In the context of the myMap method, this refers to the array on which myMap was called.
tempArray: We create a temporary array to store the results of applying the callback function to each element.
for loop: The loop iterates over each element in the array, applying the callback function, and pushing the result to tempArray.
return tempArray: Finally, the method returns the new array containing the results.
Step 3: Using the Polyfill
Once the polyfill is in place, you can use myMap just like the built-in map() method:


const arr = [1, 2, 3, 4, 5];
const squaredArray = arr.myMap(num => num ** 2);
console.log(squaredArray); // Output: [1, 4, 9, 16, 25]
This polyfill ensures that even if map() is not supported in an older browser, your code can fall back on myMap() to achieve the same
functionality.

Conclusion
Polyfills are a powerful tool for maintaining cross-browser compatibility in web applications. By creating polyfills for modern
JavaScript methods, you can ensure that your applications work seamlessly across all browsers, regardless of their version. The
example of the map() polyfill demonstrates how you can implement your own versions of modern features to support older browsers.

As you continue to develop web applications, consider incorporating polyfills to future-proof your code. In upcoming articles, we'll
explore how to create polyfills for other array methods like filter() and reduce(). Stay tuned!



Polyfills for Filter Method
---------------------------
What is the filter Method?
The filter method is a built-in array method in JavaScript that allows you to create a new array with all elements that pass a test 
implemented by the provided function. Essentially, it filters out elements based on a given condition.


let arr = [1, 2, 3, 4, 5, 6];
let result = arr.filter(number => number > 3);
console.log(result); // Output: [4, 5, 6]

In the above example, the filter method iterates over the array and returns a new array containing only the elements greater than 3.

Creating a Polyfill for the filter Method
To create a polyfill for the filter method, we need to understand its core functionality. The method iterates over an array, applies a
test function to each element, and returns a new array containing only the elements that pass the test.

Step-by-Step Process

Initialize a Temporary Array:
We start by initializing an empty array where the filtered elements will be stored.

Loop Through the Array:
Use a for loop to iterate through the array elements.

Apply the Condition:
For each element, apply the condition provided in the callback function. If the condition is true, push the element into the temporary 
array.

Return the Result:
After the loop, return the temporary array containing all elements that passed the condition.

Implementing the Polyfill
Here’s how you can implement a basic polyfill for the filter method:


Array.prototype.myFilter = function(callback) {
    let tempArray = [];
    for (let i = 0; i < this.length; i++) {
        if (callback(this[i], i, this)) {
            tempArray.push(this[i]);
        }
    }
    return tempArray;
};

Output : [ 2, 4 ]

Explanation:

Prototype Extension: We extend the Array prototype with a new method called myFilter.
Callback Function: The callback function is invoked for each element in the array. It takes three arguments: the current element, the
index of the element, and the array itself.
Condition Check: The condition is applied, and if true, the element is pushed into the tempArray.


Usage:

let arr = [1, 2, 3, 4, 5, 6];
let result = arr.myFilter(number => number > 3);
console.log(result); // Output: [4, 5, 6]
Advanced Implementation
To handle cases where additional parameters like the index and the array need to be passed, we can modify our polyfill using function 
borrowing:


Array.prototype.myFilter = function(callback) {
    let tempArray = [];
    for (let i = 0; i < this.length; i++) {
        if (callback.call(this, this[i], i, this)) {
            tempArray.push(this[i]);
        }
    }
    return tempArray;
};


Key Points:
Function Borrowing: We use callback.call(this, this[i], i, this) to invoke the callback in the context of the array, passing the current
element, its index, and the array itself.
Return Value: The polyfill works the same as the native filter method, returning a new array with the elements that pass the condition.

Conclusion
Creating polyfills is an essential skill for ensuring that your JavaScript code is robust and compatible across different environments.
The filter method is just one example of how you can implement a polyfill to mimic the functionality of modern JavaScript features in
older browsers.


Polyfills for Reduce() Method
-----------------------------
In JavaScript, the reduce() method is a powerful tool often used to accumulate values in an array into a single result. Unlike map() and
filter(), which return arrays, reduce() returns a single value. Due to its complexity and importance, the polyfill for reduce() is a 
common topic in technical interviews. Understanding how to write this polyfill will not only prepare you for interviews but also deepen
your grasp of JavaScript's functional programming.

Understanding the reduce() Method:
Before diving into the polyfill, let's explore how the reduce() method works. Consider the following example where we calculate the sum 
of all numbers in an array:

const arr = [1, 2, 3, 4, 5, 6];
const total = arr.reduce((acc, current) => acc + current, 0);
console.log(total); // Output: 21


Here’s how reduce() works:

Accumulator (acc): This parameter holds the accumulated result of the function.
Current Value (current): This parameter is the current element being processed in the array.
Initial Value: The initial value of the accumulator. If not provided, the first element of the array is used, and the iteration starts
from the second element.
If an initial value is provided, the accumulator starts with this value, and the current value starts from the first element.

Writing a Polyfill for reduce():

Let's write a polyfill for reduce() from scratch. We will implement a custom version called myReduce().

Step 1: Define the Polyfill Structure

First, we add the myReduce method to Array.prototype so it becomes available to all arrays:

Array.prototype.myReduce = function(callback, initialValue) {
    let accumulator = initialValue !== undefined ? initialValue : this[0];
    let startIndex = initialValue !== undefined ? 0 : 1;

    for (let i = startIndex; i < this.length; i++) {
        accumulator = callback.call(undefined, accumulator, this[i], i, this);
    }

    return accumulator;
};
 

Step 2: Explanation of the Code

Initial Setup:

Accumulator: If initialValue is provided, it is assigned to accumulator; otherwise, the first element of the array is used.
Start Index: If initialValue is provided, the iteration starts from index 0; otherwise, it starts from 1.

Looping Through the Array:
The loop iterates over the array starting from startIndex. For each element, the callback function is called with the accumulator, the
current element, the current index, and the entire array as arguments.

The result of the callback is assigned back to accumulator.

Returning the Result:
After the loop completes, the final value of accumulator is returned.

Step 3: Handling Edge Cases

To make the polyfill robust, you should handle edge cases, such as:

Non-function Callbacks: Ensure the callback passed is a function.
Non-array Objects: Ensure that myReduce() is called on an array.

Array.prototype.myReduce = function(callback, initialValue) {
    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }
    
    if (!Array.isArray(this)) {
        throw new TypeError('Object is not an array');
    }

    let accumulator = initialValue !== undefined ? initialValue : this[0];
    let startIndex = initialValue !== undefined ? 0 : 1;

    for (let i = startIndex; i < this.length; i++) {
        accumulator = callback.call(undefined, accumulator, this[i], i, this);
    }

    return accumulator;
};

Step 4: Testing the Polyfill

Let's test our myReduce() method to ensure it works as expected:

const arr = [1, 2, 3, 4, 5, 6];
const total = arr.myReduce((acc, current) => acc + current, 0);
console.log(total); // Output: 21

By changing the initial value or the callback logic, you can perform different accumulations, such as product calculation or finding the
maximum value in an array.

Conclusion
The reduce() method is a cornerstone of functional programming in JavaScript. Writing a polyfill for reduce() not only prepares you for
technical interviews but also solidifies your understanding of JavaScript's array methods and functional programming concepts. By
handling edge cases and ensuring robust error checking, you can create a professional-grade polyfill that showcases your attention to
detail and depth of knowledge.

As you continue to explore JavaScript, try writing polyfills for other methods like slice() and splice(). Each polyfill you write will 
strengthen your coding skills and prepare you for a wide range of programming challenges.



polyfills for flatten() Method
------------------------------


One of the frequently asked interview questions in JavaScript is how to flatten an array. Flattening an array means converting a nested
array into a single-dimensional array, removing all subarrays and nesting. This concept is essential, especially when dealing with 
complex data structures. JavaScript provides a built-in method called flat() to achieve this, but in an interview, you might be asked 
to implement this functionality yourself, which is where writing a polyfill comes into play. 

What Does Flattening an Array Mean?

Consider the following array:

const arr = [1, 2, 3, 4, [5, 6], [[7, 8]]];
Flattening this array would result in:

// Output: [1, 2, 3, 4, 5, 6, 7, 8]

The goal is to transform the nested structure into a single-level array. JavaScript’s flat() method does this up to a specified depth.


Using the flat() Method

The flat() method is simple to use:

const result = arr.flat();
console.log(result); // Output: [1, 2, 3, 4, 5, 6, [7, 8]]

By default, flat() only flattens the array one level deep. To flatten deeper levels, you can specify the depth as an argument:

const result = arr.flat(2);
console.log(result); // Output: [1, 2, 3, 4, 5, 6, 7, 8]

For arrays with unknown levels of nesting, you can use Infinity:

const result = arr.flat(Infinity);
console.log(result); // Output: [1, 2, 3, 4, 5, 6, 7, 8]

Writing a Polyfill for flat()
Now, let’s create our own version of the flat() method—a polyfill. This will help you understand how flat() works under the hood and
prepare you for similar interview challenges.

Step 1: Set Up the Polyfill Structure

We start by extending the Array.prototype with a new method called myFlat:

Array.prototype.myFlat = function(depth = 1) {
    const tempArray = [];

    function flatten(arr, depth) {
        for (let element of arr) {
            if (Array.isArray(element) && depth > 0) {
                flatten(element, depth - 1);
            } else {
                tempArray.push(element);
            }
        }
    }

    flatten(this, depth);
    return tempArray;
};

Explanation of the Code:

Array.prototype.myFlat: Adds a new method to all array instances.
depth: The number of levels to flatten. By default, it is set to 1.
tempArray: A temporary array that will hold the flattened result.
flatten(): A recursive function that checks each element of the array. If the element is an array and the depth is greater than 0, it
recursively calls itself with a decremented depth. Otherwise, it pushes the element into the tempArray.

Step 2: Testing the Polyfill
Now, let’s test our myFlat method:

const arr = [1, 2, 3, 4, [5, 6], [[7, 8]]];
const result = arr.myFlat(2);
console.log(result); // Output: [1, 2, 3, 4, 5, 6, 7, 8]

This test shows that our polyfill correctly flattens the array up to the specified depth.

How the Polyfill Works:

Initialization: We define a tempArray to store the flattened elements.
Recursive Flattening: The flatten() function is called recursively. It iterates through the array and checks if each element is an 
array. If it is, and if the depth allows, it calls itself recursively with the nested array and a decremented depth.
Adding Non-Array Elements: If the element is not an array or the depth limit has been reached, the element is pushed into tempArray.
Return the Flattened Array: Finally, after all elements have been processed, tempArray is returned as the flattened array.

Conclusion
Flattening arrays is a common operation in JavaScript, and understanding how to implement this functionality from scratch can 
significantly deepen your knowledge of recursion, array methods, and JavaScript in general. Writing polyfills like myFlat prepares you
for technical interviews and gives you a solid grasp of JavaScript’s core features.

As you continue to explore polyfills, challenge yourself by implementing others like slice(), splice(), and more. Each polyfill you
write will strengthen your understanding of JavaScript and prepare you for a wide range of coding scenarios.


Polyfills For Call() and Apply() Methods
----------------------------------------
JavaScript offers a powerful feature called "function borrowing," which allows one object to use a method belonging to another object.
This is often achieved through the call, apply, and bind methods. These methods enable explicit binding of this to a function, making
them crucial for flexible function execution. In this article, we will explore how to write polyfills for these methods, which is a
common topic in technical interviews.

Function Borrowing and Explicit Binding:

Function borrowing refers to the ability of an object to borrow a method from another object and use it as if it were its own. The
methods call, apply, and bind facilitate this borrowing by explicitly binding the this keyword to a specific object. Here’s a quick 
refresher on how each method works:

call(): Invokes a function, allowing you to pass in arguments one by one.
apply(): Similar to call(), but arguments are passed as an array.
bind(): Creates a new function that, when invoked, has its this keyword set to the provided value, with a given sequence of arguments 
        preceding any provided when the new function is called.
Now, let's delve into writing polyfills for call, apply, and bind.


Polyfill for call():

The call() method allows you to invoke a function and explicitly set this to the provided object. Here's how you can create a polyfill
for call():


Function.prototype.myCall = function(context, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('myCall must be called on a function');
    }
    context = context || window; 
    const fnSymbol = Symbol();
    context[fnSymbol] = this; 
    const result = context[fnSymbol](...args);
    delete context[fnSymbol];
    return result;
};

Explanation:

Context Binding: The function (this) is temporarily added as a method to the context object.
Unique Property: A unique symbol is used to avoid overwriting existing properties on the context object.
Invocation: The function is called with the provided arguments.
Cleanup: The temporary property is deleted from the context object to restore its original state.


Polyfill for apply():

The apply() method is similar to call(), but it takes arguments as an array. Here’s the polyfill for apply():


Function.prototype.myApply = function(context, args) {
    if (typeof this !== 'function') {
        throw new TypeError('myApply must be called on a function');
    }
    context = context || window;
    const fnSymbol = Symbol();
    context[fnSymbol] = this;
    const result = context[fnSymbol](...(args || [])); // Spread the array of arguments
    delete context[fnSymbol];
    return result;
};

Explanation:

Arguments Handling: The args array is spread into individual arguments when invoking the function.
Similar Structure: The structure is almost identical to myCall, with the primary difference being how arguments are handled.
Polyfill for bind()
The bind() method returns a new function with this bound to a specified object. Here’s how to create a polyfill for bind():


Function.prototype.myBind = function(context, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('myBind must be called on a function');
    }
    const self = this;
    return function(...newArgs) {
        return self.apply(context, [...args, ...newArgs]); // Combine pre-set args with new args
    };
};

I

Explanation:
Function Closure: myBind returns a new function that remembers the original function (self) and the context.
Argument Combination: The arguments passed during the binding (args) are combined with the arguments provided during the function's
                      invocation (newArgs).


Handling Edge Cases:
For robustness, it's essential to include edge case handling, such as ensuring that myCall, myApply, and myBind are called on functions
and that the context provided is an object. This enhances the reliability of the polyfill in different scenarios.

Conclusion:
Writing polyfills for call, apply, and bind not only deepens your understanding of how JavaScript handles function context but also 
prepares you for challenging technical interviews. By mastering these polyfills, you gain insight into the inner workings of JavaScript's
function borrowing and explicit binding mechanisms, which are foundational to advanced JavaScript development.

These polyfills are practical examples of how JavaScript's functional flexibility can be extended and customized, making you a more 
proficient and confident developer.


Polyfills For Bind() Method
---------------------------
we discussed polyfills for the call() and apply() methods in JavaScript. Now, let's dive into the polyfill for the bind() method, which
works a bit differently from call() and apply(). Unlike call() and apply(), which invoke a function immediately, bind() returns a new
function that can be invoked later. This distinction makes the bind() method unique and useful in various scenarios.

What is the bind() Method?
The bind() method creates a new function that, when invoked, has its this keyword set to a specified value, along with a given sequence
of arguments preceding any provided when the new function is invoked. It does not immediately call the function but instead returns a 
function that can be executed later.

Example:

const user = {
    name: 'Prakash',
    city: 'Mumbai'
};

function displayUserInfo(state) {
    console.log(`Hi, I am ${this.name} from ${this.city}, ${state}.`);
}

const boundFunction = displayUserInfo.bind(user, 'Maharashtra');
boundFunction(); // Output: Hi, I am Prakash from Mumbai, Maharashtra.

In this example, the bind() method is used to bind the user object to the displayUserInfo function, along with the argument 'Maharashtra'.
The returned boundFunction can be invoked later, retaining the context and arguments passed during the binding.

Creating a Polyfill for bind():

Now, let's create a polyfill for the bind() method. A polyfill is a piece of code that replicates the functionality of a newer feature 
in older environments where it is not supported natively.

Step 1: Define the Polyfill Function
First, we extend the Function.prototype with our custom myBind method:


Function.prototype.myBind = function(context, ...args) {
    const func = this;
    return function(...rest) {
        return func.apply(context, [...args, ...rest]);
    };
};

Explanation of the Code:
 

Function.prototype.myBind: This extends the Function.prototype with a new method called myBind.
context: The context parameter is the object to which this should refer when the new function is called.
args: The rest parameter (...args) captures any additional arguments passed during the binding process.
func: The this keyword inside myBind refers to the function on which myBind is called. We store this function in the func variable.
return function: myBind returns a new function that, when invoked, calls the original function (func) with the specified context and
                 arguments.
apply(): Inside the returned function, apply() is used to call the original function with the combined arguments (...args and ...rest).

Step 2: Testing the Polyfill

Let's test our myBind polyfill to ensure it works as expected:


const user = {
    name: 'Prakash',
    city: 'Mumbai'
};

function displayUserInfo(state) {
    console.log(`Hi, I am ${this.name} from ${this.city}, ${state}.`);
}

const boundFunction = displayUserInfo.myBind(user, 'Maharashtra');
boundFunction(); // Output: Hi, I am Prakash from Mumbai, Maharashtra.
This test confirms that our myBind polyfill successfully replicates the functionality of the native bind() method.


Understanding the Execution Flow:

Context Binding: The context (in this case, the user object) is passed to the myBind method, which sets this inside the returned
                 function to refer to user.
Argument Handling: The initial arguments (...args) are captured during the binding. When the returned function is invoked later, any
                     additional arguments (...rest) are combined with the initial ones.
Function Invocation: The original function (displayUserInfo) is called using apply() with the bound context and combined arguments.


Conclusion:

The bind() method is a powerful tool in JavaScript, allowing developers to create functions with a predetermined this context and
initial arguments. By creating a polyfill for bind(), we've ensured that this functionality is available even in environments where the 
native bind() method may not be supported.

Understanding how to implement polyfills not only helps in writing backward-compatible code but also deepens your understanding of how 
JavaScript functions operate under the hood. The concepts learned here are valuable for both improving your JavaScript skills and 
preparing for technical interviews, where polyfills are a common topic.



Prototype 
---------

In JavaScript, every object has an internal and hidden property called [[Prototype]], which is either null or references another object.
This property allows JavaScript to implement a feature known as "prototypal inheritance." Understanding prototypes is crucial for 
grasping how JavaScript objects inherit properties and methods.

What is a Prototype?

A prototype in JavaScript is a special hidden property of an object. This property either holds a reference to another object (the 
prototype) or is null. The object referenced by the prototype is used to provide inheritance. For example, methods and properties 
defined on a prototype can be accessed by all objects that inherit from that prototype.

Consider the following example:

let user = {
    name: "Prakash",
    role: "mentor"
};

console.log(user);
When you log the user object, you can see its properties (name and role). However, there's also a hidden [[Prototype]] property, which
you can see by expanding the object in a browser's developer console.


Accessing Prototype Methods:

The prototype object contains methods and properties that can be accessed by the object itself. For example, JavaScript objects have a 
toString method, which is available through the prototype:

console.log(user.toString()); // Outputs: [object Object]

Even though toString is not directly defined in the user object, JavaScript looks for it in the object's prototype and executes it. This
behavior is due to prototypal inheritance, where an object tries to access a property or method. If it's not found within the object 
itself, JavaScript looks up the prototype chain to find it.


Creating Custom Prototypes:

You can also create your own prototypes to define custom behaviors for your objects. Here's an example:


const admin = {
    isAdmin: true
};

let user = {
    name: "Prakash",
    role: "mentor",
    __proto__: admin
};

console.log(user.isAdmin); // Outputs: true

In this example, we create an admin object with a property isAdmin. We then set the __proto__ of the user object to admin, which means
the user object now inherits from admin. As a result, user.isAdmin returns true.


Prototype Chaining:

Prototypes in JavaScript can be chained, allowing objects to inherit from multiple prototypes. For instance:


const loggedInStatus = {
    isLoggedIn: true
};

admin.__proto__ = loggedInStatus;

console.log(user.isLoggedIn); // Outputs: true
Here, we added another level of prototype chaining by setting admin's prototype to loggedInStatus. Now, the user object can access 
properties from both admin and loggedInStatus through prototype chaining.


Overriding Prototype Methods:

If an object defines a method or property that is also defined in its prototype, the object's method or property will override the 
prototype's. For example:


JavaScriptuser.showMessage = function() {
    console.log("Hello, User!");
};

admin.showMessage = function() {
    console.log("User is an admin.");
};

user.showMessage(); // Outputs: "Hello, User!"
In this example, even though admin has a showMessage method, the user object's own showMessage method takes precedence.


Accessing Prototype Properties and Methods:

You can access an object's own properties using Object.keys(), but this method only returns properties directly on the object, not those
inherited from the prototype:

console.log(Object.keys(user)); // Outputs: ["name", "role"]
To access all properties, including those from the prototype, you can use a for...in loop:

for (let key in user) {
    console.log(key); // Outputs: "name", "role", "isAdmin", "isLoggedIn"
}

Conclusion:
Prototypes are a powerful feature in JavaScript that enable objects to share and inherit properties and methods. By understanding how
prototypes work, you can leverage inheritance and method overriding to write more flexible and reusable code.

While prototypes are foundational in JavaScript, their use is often abstracted away by higher-level constructs like classes. However,
having a solid grasp of how prototypes work under the hood will make you a more proficient JavaScript developer.



OBJECT ORIENTED PROGRAMMING IN JAVASCRIPT
-----------------------------------------
Object-Oriented Programming (OOP) is a programming paradigm that relies on the concept of classes and objects. It's a powerful tool for
organizing and structuring your code in a way that models real-world entities and relationships. In this article, we’ll delve into the
basics of OOP by exploring classes and objects in JavaScript, providing a strong foundation for more advanced topics like inheritance 
and encapsulation.

What is a Class?
In simple terms, a class is a blueprint for creating objects. Think of it as a template that defines the structure and behavior of
objects. For instance, if you were to design a series of mobile phones, you would start with a single blueprint that specifies the
design and features. From this blueprint, you can manufacture as many phones as you want, each with the same specifications. Similarly,
in programming, a class allows you to define a template for objects.

Example: Creating a User Class
Let's consider a real-world scenario where you need to manage data for students in a school. You want to store their names, roles, 
login status, and whether they have administrative privileges. Instead of manually creating an object for each student, you can define
a User class that serves as a blueprint for all student objects.

Here’s how you can define a basic User class in JavaScript:


class User {
    constructor(name, role, isAdmin, isLoggedIn) {
        this.name = name;
        this.role = role;
        this.isAdmin = isAdmin;
        this.isLoggedIn = isLoggedIn;
    }
}
In this example, the constructor method is used to initialize the properties of the class. These properties include name, role, isAdmin,
and isLoggedIn. When you create a new User object, you provide these values as arguments.

Creating Objects from a Class:
Using the User class, you can now create multiple objects, each representing a different student:


const user1 = new User('Prakash', 'Mentor', false, true);
const user2 = new User('Ashish', 'Mentor', false, true);
const user3 = new User('Sakshi', 'Mentor', false, true);

console.log(user1); // Output: User {name: 'Prakash', role: 'Mentor', isAdmin: false, isLoggedIn: true}
console.log(user2); // Output: User {name: 'Ashish', role: 'Mentor', isAdmin: false, isLoggedIn: true}
console.log(user3); // Output: User {name: 'Sakshi', role: 'Mentor', isAdmin: false, isLoggedIn: true}
Each object—user1, user2, and user3—is an instance of the User class, containing its own set of properties based on the values passed 
to the constructor.

Adding Methods to a Class:
Classes can also have methods that define the behavior of the objects created from the class. For example, you might want to display the 
information of each user:


class User {
    constructor(name, role, isAdmin, isLoggedIn) {
        this.name = name;
        this.role = role;
        this.isAdmin = isAdmin;
        this.isLoggedIn = isLoggedIn;
    }

    displayInfo() {
        console.log(`${this.name} is a ${this.role}`);
    }
}

user1.displayInfo(); // Output: Prakash is a Mentor
user2.displayInfo(); // Output: Ashish is a Mentor
user3.displayInfo(); // Output: Sakshi is a Mentor
The displayInfo method uses the this keyword to access the properties of the object. It logs a message to the console that includes the 
user's name and role.

Understanding the Prototype:
In JavaScript, methods defined in a class are not directly stored in the objects themselves. Instead, they are stored in the object’s
prototype. When you call a method on an object, JavaScript looks for that method in the object's prototype chain.

console.log(Object.getPrototypeOf(user1)); // Output: User {constructor: ƒ, displayInfo: ƒ}
The displayInfo method is part of the prototype, not the individual User objects. This is an efficient way to handle methods, as they 
don’t need to be duplicated across multiple objects.

How Classes Work Under the Hood:
When a class is declared in JavaScript, it effectively creates a function. The constructor function, which initializes the properties 
of the class, becomes the body of this function. When you use the new keyword to create an instance of the class, JavaScript constructs
an object that includes the properties defined in the constructor and links it to the prototype, where methods are stored.

Conclusion
Understanding classes and objects is fundamental to mastering Object-Oriented Programming in JavaScript. A class acts as a blueprint, 
allowing you to create multiple objects with the same structure and behavior. By defining methods within a class, you can encapsulate 
functionality that applies to all objects created from that class. As you continue to explore OOP, you’ll discover more advanced
concepts like inheritance and encapsulation, which further enhance your ability to write organized and efficient code.


Classes Inheritance
-------------------

Inheritance is a fundamental concept in object-oriented programming (OOP), allowing one class to inherit properties and methods from 
another class. This mechanism promotes code reuse and enhances the organization of your code by establishing relationships between 
classes. In this article, we'll explore the concept of class inheritance in JavaScript and how it can be used to create more structured 
and maintainable code.

What is Inheritance?
Inheritance, in the context of programming, is the process by which one class (known as the child or subclass) acquires the properties
and behaviors (methods) of another class (known as the parent or superclass). This is similar to the way in which children inherit 
traits from their parents. In programming, inheritance allows a subclass to inherit features from a superclass, thus enabling code 
reuse and a hierarchical relationship between classes.

Basic Example: Laptop and Specific Brands
Let's consider a real-world example where we have a generic Laptop class that contains common properties like RAM, Processor, and 
Generation. Specific laptop brands like Dell and Lenovo can then inherit these properties from the Laptop class, adding their unique
attributes as needed.

Here's how you can define the Laptop class:

class Laptop {
    constructor(ram, processor, generation) {
        this.ram = ram;
        this.processor = processor;
        this.generation = generation;
    }

    displaySpecs() {
        console.log(`Laptop Specs: RAM = ${this.ram}, Processor = ${this.processor}, Generation = ${this.generation}`);
    }
}
In this example, the Laptop class has a constructor that initializes the ram, processor, and generation properties. It also has a method 
displaySpecs that logs these specifications to the console.

Creating a Subclass with Inheritance:
Now, let's say we want to create a Dell class that represents a specific brand of laptops. Instead of redefining the ram, processor, and
generation properties in the Dell class, we can simply inherit these from the Laptop class using the extends keyword.


class Dell extends Laptop {
    constructor(ram, processor, generation, modelName, price) {
        super(ram, processor, generation); // Call the parent class's constructor
        this.modelName = modelName;
        this.price = price;
    }

    displaySpecs() {
        super.displaySpecs(); // Call the parent class's displaySpecs method
        console.log(`Model Name = ${this.modelName}, Price = ${this.price}`);
    }
}

Here, the Dell class extends the Laptop class, meaning it inherits all the properties and methods from the Laptop class. The constructor
method in Dell uses the super keyword to call the parent class's constructor, ensuring that ram, processor, and generation are properly
initialized. The Dell class also adds two new properties: modelName and price.


Creating Instances and Accessing Methods:
Let's create an instance of the Dell class and see how inheritance works in practice:

const dellLaptop = new Dell('8GB', 'Intel i5', '10th Gen', 'Dell Latitude', 45000);
dellLaptop.displaySpecs();
When you run this code, the following output will be displayed:

Laptop Specs: RAM = 8GB, Processor = Intel i5, Generation = 10th Gen
Model Name = Dell Latitude, Price = 45000
Here’s what’s happening:

The Dell class inherits the displaySpecs method from the Laptop class and extends it to include modelName and price.
The super keyword is used to call the parent class's methods and constructors, ensuring that the properties defined in Laptop are 
correctly initialized in the Dell subclass.


Adding More Subclasses:
The beauty of inheritance is that it allows for easy expansion. Suppose you want to create another subclass for a different brand, such 
as Lenovo. You can do this by simply extending the Laptop class, just as we did with the Dell class:


class Lenovo extends Laptop {
    constructor(ram, processor, generation, modelName, price) {
        super(ram, processor, generation);
        this.modelName = modelName;
        this.price = price;
    }

    displaySpecs() {
        super.displaySpecs();
        console.log(`Model Name = ${this.modelName}, Price = ${this.price}`);
    }
}

const lenovoLaptop = new Lenovo('16GB', 'AMD Ryzen 7', '5th Gen', 'Lenovo ThinkPad', 60000);
lenovoLaptop.displaySpecs();
This code will output:

Laptop Specs: RAM = 16GB, Processor = AMD Ryzen 7, Generation = 5th Gen
Model Name = Lenovo ThinkPad, Price = 60000
Understanding the super Keyword

The super keyword plays a crucial role in class inheritance:

Calling the Parent Constructor: When used inside a subclass constructor, super() calls the parent class's constructor, allowing the
                                subclass to inherit and initialize properties defined in the parent class.
Calling Parent Methods: The super keyword can also be used to call methods from the parent class within the subclass, enabling the 
                        subclass to build upon or override these methods.

Conclusion:
Class inheritance is a powerful feature in JavaScript that allows developers to create hierarchical relationships between classes, 
promoting code reuse and reducing redundancy. By using the extends keyword and the super function, subclasses can inherit properties
and methods from parent classes, while also adding their unique characteristics. This not only makes your code more organized and 
maintainable but also closely mirrors real-world relationships and hierarchies.


Static Properties and Methods
-----------------------------

In JavaScript, classes can have special types of methods and properties known as "static methods" and "static properties." These are
distinct from regular methods and properties because they are associated with the class itself rather than with instances (objects) 
created from the class. Let’s explore what these are and how they can be used.

What are Static Methods?
Static methods are functions defined on the class itself, rather than on instances of the class. This means that you can call a static 
method directly on the class, without having to instantiate an object from the class.

Example:

class Children {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static sortByAge(child1, child2) {
        return child1.age - child2.age;
    }
}

let child1 = new Children("Prakash", 11);
let child2 = new Children("Ashish", 19);
let child3 = new Children("Ria", 9);

let childrenArray = [child1, child2, child3];
childrenArray.sort(Children.sortByAge);

console.log(childrenArray);
In this example, sortByAge is a static method that sorts an array of Children objects by their age. Since sortByAge is static, it's 
called on the Children class itself, not on an instance of Children.

Why Use Static Methods?
Static methods are useful when you want to perform operations that are related to the class, but not to any specific object of that 
class. For example, if you want to perform operations on a collection of objects or need utility functions related to the class, static 
methods are the right choice.

What are Static Properties?
Static properties are variables that are attached to the class itself rather than to objects created from the class. This means all 
instances of the class share the same static property.

Example:

class Children {
    static ID = 1;

    constructor(name, age) {
        this.name = name;
        this.age = age;
        this.id = Children.ID++;
    }
}

let child1 = new Children("Prakash", 11);
let child2 = new Children("Ashish", 19);
let child3 = new Children("Ria", 9);

console.log(child1.id); // Outputs: 1
console.log(child2.id); // Outputs: 2
console.log(child3.id); // Outputs: 3

In this example, ID is a static property. It is used to assign a unique ID to each child object. Each time a new Children object is 
created, the ID property is incremented.

Accessing Static Properties and Methods
To access a static method or property, you use the class name itself, not an instance of the class:

console.log(Children.ID); // Accessing the static property
Children.sortByAge(child1, child2); // Accessing the static method
Use Cases for Static Methods and Properties
Utility Functions: Static methods are perfect for utility functions that apply to the entire class, such as sorting or searching through
                    a collection of objects.
Counters: Static properties can be used to keep track of data across all instances, like assigning unique IDs to objects or counting 
          how many instances of the class have been created.
Configuration Constants: You can use static properties to store configuration values that are the same across all instances of the class.


Practical Example
Let’s consider a scenario where you need to find all children above a certain age:


class Children {
    static ID = 1;

    constructor(name, age) {
        this.name = name;
        this.age = age;
        this.id = Children.ID++;
    }

    static filterByAge(childrenArray, ageLimit) {
        return childrenArray.filter(child => child.age > ageLimit);
    }
}

let child1 = new Children("Prakash", 11);
let child2 = new Children("Ashish", 19);
let child3 = new Children("Ria", 9);

let olderChildren = Children.filterByAge([child1, child2, child3], 10);

console.log(olderChildren); // Outputs: child1 and child2

Output
[
  Children { name: 'Prakash', age: 11, id: 1 },
  Children { name: 'Ashish', age: 19, id: 2 }
]
Here, filterByAge is a static method that filters and returns an array of Children objects that are older than a specified age.

Conclusion:
Static methods and properties are powerful tools in JavaScript that allow you to create methods and properties that are tied to the
class itself, rather than to instances of the class. They are particularly useful for utility functions, shared counters, and 
configuration constants. Understanding how to effectively use static methods and properties can help you write more efficient and
organized code.


Private Properties
------------------

In modern JavaScript development, controlling access to certain properties within a class is crucial for maintaining the integrity and
security of your code. This is where private properties come into play. Private properties are those that cannot be accessed or modified
from outside the class, thus ensuring that certain data remains protected and only modified in a controlled manner. In this article, 
we'll explore how to create and use private properties in JavaScript, including the latest syntax additions and their implications.

What Are Private Properties?
Private properties are variables that are meant to be inaccessible from outside the class in which they are defined. They help enforce 
encapsulation—a core principle in object-oriented programming (OOP)—by restricting direct access to certain data within a class. This 
ensures that the data is only accessible through controlled methods, reducing the risk of unintended side effects from direct 
modifications.

Creating a Private Property in JavaScript:
To illustrate private properties, let's consider a simple User class where each user has a unique ID. We want to ensure that this ID
cannot be changed directly from outside the class.

Here's how you might define the User class with a public property:


class User {
    constructor(id) {
        this.id = id; // Public property
    }
}

const user = new User('123');
console.log(user.id); // Output: 123

user.id = '321';
console.log(user.id); // Output: 321 (ID has been changed externally)
In the example above, the id property is public, meaning it can be accessed and modified directly from outside the class. This could 
lead to potential issues if the ID is inadvertently changed.

To convert this into a private property, you can use the new private field syntax by adding a # before the property name:


class User {
    #id; // Private property
    
    constructor(id) {
        this.#id = id;
    }

    // Method to access the private ID
    getId() {
        return this.#id;
    }

    // Method to change the private ID
    changeId(newId) {
        this.#id = newId;
    }
}

const user = new User('123');
console.log(user.getId()); // Output: 123

// Attempting to access or modify the private property directly will result in an error
user.#id = '321'; // SyntaxError: Private field '#id' must be declared in an enclosing class

// Changing the ID through the class method
user.changeId('321');
console.log(user.getId()); // Output: 321


Key Features of Private Properties:
Private Fields Syntax: The # symbol is used before the property name to declare it as private. This is a recent addition to JavaScript 
                        and ensures that the property is only accessible within the class.
Encapsulation: By using private properties, you ensure that critical data cannot be altered from outside the class. This makes your code
                more robust and secure.
Controlled Access: You can provide controlled access to private properties through methods defined within the class, as shown with the
                    getId and changeId methods in the example.

Limitations and Browser Support:
While private properties add a valuable layer of protection, they come with some limitations:

Not Yet Universally Supported: The private fields syntax (#) is a relatively new feature and may not be supported in all JavaScript 
    environments, especially older browsers. Developers might need to use polyfills or transpilers like Babel to ensure compatibility.
No Access Outside the Class: Once a property is marked as private using #, it cannot be accessed or modified outside the class by any 
                                means, making it a strictly controlled entity.


Conclusion:
Private properties in JavaScript provide a powerful way to enforce encapsulation and protect your data from unintended external 
modifications. By using the # syntax, you can easily declare private properties within your classes and control their accessibility
through class methods. As this feature continues to gain support across browsers and environments, it will become an essential tool in
every JavaScript developer's toolkit.

Incorporating private properties into your code is a step toward writing more secure, maintainable, and predictable applications. So, 
start experimenting with private properties in your projects, and enjoy the benefits of encapsulated, clean code!



ASYNCHRONOUS JAVASCRIPT
-----------------------

Callback functions
------------------

A callback function is a function that is passed as an argument to another function and is invoked or called by that function at a 
certain point in time. The main purpose of a callback function is to allow asynchronous processing or non-blocking behavior in 
programming languages that support it. Callback functions are commonly used in event handling, such as when responding to user actions 
or when performing operations that require significant time to complete. They are also used in higher-order functions that take other 
functions as arguments, such as map(), filter(), and reduce() function in JavaScript.

let us try to understand with the help of the example 


function outer(wrapper){
 console.log("Outer function is called");
 wrapper();
}
function callback(){
  console.log("function b is called");
}
outer(callback);

Output
Outer function is called
function b is called
 

It is important to remember that the execution of the callback function depends upon the execution of the function, which the callback
is passed to.

Let us understand how callback functions are useful for async Programming.

Take an example of setTimeout method  - It is a method used to execute a piece of code after a certain delay.
 


console.log("hello");
setTimeout(function callback(){
  console.log("Delayed by 4 seconds ");

},4000)

Output
hello
Delayed by 4 seconds 
 

Here the callback function passed to setTimeout executes after a delay of 4 seconds hence it is useful in async Programming.


Another example of a callback function could be the use case of fetch.

fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json())
  .catch(error => console.error(error));

Here we are making a network call to fetch some data from the JSON placeholder and we are waiting for the response to come back, once we
receive the response our callback function is executed which is passed as an argument to the then method. In case Our response fails, our
callback function for the catch method is called.

Without the concepts of Callback Functions ,async Programming could not be possible.



How async Js Works Under the hood?
----------------------------------

JavaScript is a Single-threaded Synchronous language by single Threaded means that the js engine has a single thread to execute 
instructions. By synchronous, it means that the js engine executes code line by line (one line at a time).

What is Async Programming?
Async programming is a programming model that allows code to run asynchronously or non-blocking. This means that while a task is being
executed, other code can continue to run concurrently without waiting for the task to complete.

So how does async behavior is achieved by JavaScript?
It is important to understand that the js engine only has a single call stack to execute js code but it still manages to make async 
programming work like fetching data from a server, calling set timeout, providing timer, local Storage, etc. So How do JS engines 
execute all that?

The ability of js to execute async tasks like calling an API, doing console.log, and manipulating dom events is not part of the js
engine but it is provided by the browser where the js engine executes javascript code. Let's look at the image below to understand
what all functionalities the browser provides to the js Engine.

 


 
The timer is provided by the browser which allows the power to execute methods like setTimeout and setInterval that allow certain 
delays in the set timeout call.

All the dom-related methods to access and attach event listeners on certain nodes are also provided by Browser to the js engine.
Even the most famous console is not part of the js engine but is part of web-api provided by the browser.

Let us now try to understand how async code gets executed.

Example -1 


console.log("Line1");
setTimeout(function callback1(){
  console.log("Line3");
  
},3000);
console.log("Line6");
 


Output
Line1
Line2
Line3
To understand how this code works out we need to understand the event loop and callback queue 

Event Loop  
In JavaScript, an event loop is a mechanism that enables asynchronous programming. The event loop works by continuously processing a
queue of events and executing any associated callbacks or functions.

Callback Queue
In JavaScript, the callback queue is a mechanism used by the event loop to manage asynchronous code execution. Whenever an asynchronous
operation is performed, such as a timer set by setTimeout() or an HTTP request made by fetch(), the associated callback function is 
added to the callback queue.

The event loop constantly monitors the callback queue and executes the callbacks in the order in which they were added, one at a time.
This ensures that the JavaScript runtime remains single-threaded and that no two callbacks are executed simultaneously.

Explanation For the code example above 

first, line1  is executed and it simply prints console.log("line1") then as soon as js engines encounter setTimeout it sets a timer in
the web API and the call stack gets empty then line 6 gets executed due to javascript synchronous and non-blocking nature. Once the 
timer is expired in the web-API it registers and passes the callback function in the callback queue also at the same time event loop 
is continuously monitoring the call stack whether it is empty or not, once it sees the call stack as empty it pushes the callback 
method in the call stack and then callback function gets executed and it prints to console.log("line6");

 Example 2 


console.log("lets Start");   // line1
const btnAddtoCart = document.getElementById("btn");  //line2
btnAddtoCart.addEventListener("click",()=> {     //line3
  console.log("Button Clicked");
});
console.log("Bye Bye ......");
Let us try to understand the execution of the code above line by line.

Initially, the line1 console.log("Let Start") is printed then js engine moves to the next line and extracts the node from the DOM and
saves its reference in a variable called btnAddtoCart.
Then as soon it encounters line 3, event listener is registered in the web-API and the js engine moves forward and prints the last 
line console.log("Bye Bye ").
Once a user clicks on the button to which the event listener is attached, the callback is pushed into the callback queue, and once 
the event loop finds the call stack as empty callback queue pushes the callback function into the call stack, and the function gets 
executed.

So the output of the above will always be:
"lets Start"
"Bye Bye ....."
"Button Clicked"
 
Here is the image of the Event loop and callback queue
 



We have an important point to understand in case we have both the setTimeout and Promise callbacks in our code then whose Callback will
be executed first?

The callback queue is the queue which is also known by the name task Queue but we also have a queue named microTask queue.
All the promised-based callbacks are registered inside the microtask queue and have the highest priority and all the other types of 
callback are pushed into the callback queue or the task queue as it have less priority then the microtask queue.



Callback hell
-------------

In JavaScript, the scenario where the code becomes densely nested and challenging to read due to the overuse of callbacks is referred
to as "callback hell." When using asynchronous actions, like network requests or file operations, where the code must wait for a 
response before continuing, this can happen. It can be difficult to handle the code and to keep track of the execution flow when 
several callbacks are chained together and nested inside one another. For developers, this can result in bugs, mistakes, and a great
deal of stress.

let us try to understand this by considering this scenario - : 

On a hotel booking website, the general flow to booking a hotel is this - :
First API is called to book a hotel then an API is called to Proceed To Payment then after that, an API is called to showBookingStatus 
then internally an API is called to updateBookingHistory at the server side. Now let's try to implement this in a piece of code 


bookHotel(hotelId,function(){
     if(err){
         errorHandler();
      }else{
         proceedToPayment(hotelId,function(){
            if(err){
              erroHandler();
            }else{
              showBookingStatus(hotelId,function(){
                 if(err){
                   errorHandler();
                 }else{
                   updateBookingHistroy(hotelId,function(){
                     success();
                   })
                  }
              })
             }
         })
       }
})
 

Now we are calling an API called book hotel and depending upon the response we are calling another API known as proceedToPayment 
depending upon the result of the previous API we are calling another API.

So this creates two problems-
1 Pyramid Of Doom
2 Inversion of Control 

If you take a look at the above code it is clear that our code is expanding in the horizontal direction instead of the vertical 
direction which is considered a bad practice in programming as it makes the code less readable and difficult to identify bugs as well.

The second Problem with this callback style of Programming is the inversion of control, the callback function's actual control is given
to the function that it is being passed as an argument into so suppose our API gets into the ideal State i.e we get no response from the
server our callback function will never be executed 

In order to resolve these issues we use promises and the async-await style of async programming.


Promises in Javascript
----------------------
In JavaScript, a Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its
resulting value. It allows you to write asynchronous code in a more readable and manageable way, avoiding callback hell (nested 
callbacks).

A promise can be in one of three states:

1. Pending: The initial state, neither fulfilled nor rejected.
2. Fulfilled: The operation completed successfully, and the promise has a resulting value.
3. Rejected: The operation failed, and the promise has a reason for the failure.

Syntax of a Promise:

let promise = new Promise(function(resolve, reject) {
  // asynchronous code
  if (success) {
    resolve("Success!"); // When the operation is successful
  } else {
    reject("Error!"); // When the operation fails
  }
});

Handling a Promise:
You use .then() to handle the fulfilled case and .catch() to handle the rejected case.


promise
  .then(function(result) {
    console.log(result); // Success! Do something with the result
  })
  .catch(function(error) {
    console.log(error); // Error! Handle the error
  });
Example:
javascript
Copy code
let myPromise = new Promise(function(resolve, reject) {
  setTimeout(function() {
    resolve("Promise fulfilled!");
  }, 1000);
});

myPromise.then(function(result) {
  console.log(result); // Logs "Promise fulfilled!" after 1 second
});
In this example, after 1 second, the promise is resolved, and the then() function runs to handle the success.

(gfg notes starts here)

A promise in JavaScript represents the eventual outcome of an asynchronous operation and its value, whether successful or failed. 
Promises are commonly used to handle various asynchronous tasks such as fetching data from an API, reading files, or waiting for a
timer to expire.

Consider Promise as a special Object in Javascript which has different states and corresponding different values of each state.
A promise is initially in a pending state and changes to either a "Fulfilled" or "rejected" state depending on whether the promise was
resolved or rejected. Initially, the value of the promise is undefined and changes to the value of the resolve(value) method if the
promise is successful or changes to an error in case the reject(error) method is called.


Look at this diagram to understand it in a better way.

 
 

Now let us Understand How can we consume promises?
In case we are fetching data from an API using the fetch method which returns a promise we need to consume it to read the actual 
response from the server. let us look at the example of a fetch call and how can we consume a promise returned by Fetch().
 


let promise1 = fetch('https://randombig.cat/roar.json');
promise1.then(function(response){
  return response.json();
}).then(function(commits){
 alert(commits[0].author.login)
}).catch(function(error){
 alert("Some Error in fetching response")
});

In the code above we have special methods then and catch which are used to consume promises. we attach then method to the promise and
pass a callback function to then method which will be executed once the promise is successfully resolved in case the promise is rejected
catch method callback function gets executed and displays the appropriate response.

It is important to remember that each call on then method also returns the promise whose fulfilled value is equal to the value returned 
by the callback function inside then method.
 

Creating a Promise and Method Chaining
--------------------------------------

In this article, we will learn how can we create our own Promise.

We use new Promise Constructor Syntax to create a new Promise -

let promise = new Promise(function(resolve, reject) {
 // executor 
});

The executor is the function that is provided to the new Promise. When a new Promise is created, the executor is executed automatically.
The callbacks, resolve, and reject, are provided by JavaScript itself, and our code is only contained within the executor. Regardless
of whether the result is obtained soon or late, the executor must call either the resolve(value) callback, indicating successful
completion of the job along with the result value, or the reject(error) callback, indicating an error object if an error occurred.

let us try to understand this with the help of an example 


const isRequestSuccessfull = true;

let promise = new Promise((resolve,reject)=>{
  if(isRequestSuccessfull){
   resolve("promise resolved");
  }else{
   const error = new Error("Something Went Wrong");
   reject(error.message);
  }
});

console.log(promise);

Output
Promise { 'promise resolved' }

As in the above code, the executor function runs immediately and calls resolve inside the if condition.If the value of
isRequestSuccessfull is false then it would have called reject and with the promise state as Rejected. Now let us see how can we consume
our promise code using the then and catch method.

See the code below 
 


const isRequestSuccessfull = true;

let promise = new Promise((resolve,reject)=>{
  if(isRequestSuccessfull){
   resolve("promise resolved");
  }else{
   const error = new Error("Something Went Wrong");
   reject(error.message);
  }
});

promise.then(response=>console.log(response))
.catch(err=>console.log(err));

Output
promise resolved
It is important to remember that in case the executor calls the resolve method, the value of the response parameter in the callback of 
then method will always be equal to the value passed in as the argument while calling the resolve method resolve(value). So then method 
is used to handle successful responses generally, although it is also capable of handling the reject response as well.

Now let us see what happens in case the promise is Rejected.


const isRequestSuccessfull = false;

let promise = new Promise((resolve,reject)=>{
  if(isRequestSuccessfull){
   resolve("promise resolved");
  }else{
   const error = new Error("Something Went Wrong");
   reject(error.message);
  }
});

promise.then(response=>console.log(response))
.catch(err=>console.log(err));

Output
Something Went Wrong
Here we can see that the output is "Something Went Wrong" because the promise was rejected catch method callback was fired and the value
of the err is equal to the argument passed into the reject() method inside the executor function.

Now let us see how can we handle multiple chaining using then method.

Promise Chaining: Promise Chaining is a simple concept by which we may initialize another promise inside our .then() method and 
accordingly we may execute our results. The function inside then captures the value returned by the previous promise



The syntax for using promise chaining is as follows.


    let promise = new Promise((resolve, reject) => {
    resolve("Hello JavaScript");
    });
     
    promise
    .then( function (result1){
        console.log(result1);
        return new Promise((resolve,reject) =>{
            resolve("GFG is awesome");
        })
    })
    .then((result2) => {
        console.log(result2);
    });

Output
Hello JavaScript
GFG is awesome
Lets see another example:


function asyncOperation(value) {
  return new Promise((resolve, reject) => {
    // Simulating an asynchronous operation
    setTimeout(() => {
      const result = value * 2;
      resolve(result);
    }, 1000);
  });
}

// Chain multiple 'then' methods
asyncOperation(3)
  .then(result1 => {
    console.log(`Step 1: ${result1}`);
    return result1 + 5;
  })
  .then(result2 => {
    console.log(`Step 2: ${result2}`);
    return result2 * 3;
  })
  .then(finalResult => {
    console.log(`Final Result: ${finalResult}`);
  })
  .catch(error => {
    console.error(`Error: ${error}`);
  });

Output:

Step 1: 5

Step 2: 0

Final Result: 0



Promise API'S - promise.all(), Promise.allSettled(), Promise.race() v/s Promise.any()
-------------------------------------------------------------------------------------

The  Promise API comprises a collection of JavaScript functionalities that facilitate the handling of asynchronous code in a more
graceful and comprehensible manner. Essentially, a Promise is an object that denotes a value that might not be accessible immediately
but will be resolved eventually.
We will cover Promise.all() ,Promise.allSettled(), Promise.race() v/s Promise.any() in this article .

Promise.all()

Consider a scenario where we have to execute multiple promises in parallel and wait until all of them are ready. For instance, download 
several URLs in parallel and process the content once they are all done.

The syntax is:
let promise = Promise.all(); 
Let us Try to Understand this with an example.
 


let promise1 = new Promise(resolve => setTimeout(() => resolve(1), 3000));
let promise2 = new Promise(resolve => setTimeout(() => resolve(2), 2000)); // 2
let promise3 = new Promise(resolve => setTimeout(() => resolve(3), 1000)); // 3

let finalPromise = Promise.all([promise1,promise2,promise3]);
finalPromise.then(res=>console.log(res)).catch(err=>console.log(err));

Output
[ 1, 2, 3 ]
Here You can see that the result Promise gives an array consisting of resolved promises value.

Please note that the order of the resulting array members is the same as in its source promises. Even though the first promise takes the
longest time to resolve, it’s still first in the array of results.
It is important to observe that the sequence of elements in the resulting array corresponds to that of the source promises. This implies
that although the initial promise may take the most time to resolve, it will still be the first member in the outcome array.

let us Look at another example in which we are fetching different url of different GitHub profiles.


const urls = [
  'https://api.github.com/users/prakashsakari',
  'https://api.github.com/users/AshishJangra27',
];
const requests = urls.map(url => fetch(url));
Promise.all(requests)
  .then(responses => responses.forEach(
    response => console.log(`${response.url}: ${response.status}`)
  )).catch(err => console.log(err.message));

The output of the above code will be 
https://api.github.com/users/prakashsakari: 200
https://api.github.com/users/AshishJangra27: 200

Promise.allSettled()

Promise.all rejects as a whole if any promise rejects. That’s good for “all or nothing” cases when we need all results successful to 
proceed.Promise.allSettled just waits for all promises to settle, regardless of the result. 
The resulting array will be -
{status: "fulfilled", value: result} for successful responses 
{status: "rejected", reason: error} for errors

look at the code below to understand better.

 


let urls = [
  'https://api.github.com/users/prakashsakari',
  'https://api.github.com/users/AshishJangra27',
  'https://no-such-url'
];
Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        console.log(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        console.log(`${urls[num]}: ${result.reason}`);
      }
    });
  });

The output of the above code will be 
[
 {status: 'fulfilled', value: ...response...},
 {status: 'fulfilled', value: ...response...},
 {status: 'rejected', reason: ...error object...}
]
We can see even when the third promise is rejected the overall result of the promise is not rejected  but it gives the successful
response of the first two promises and only shows rejected for the promise that was rejected unlike promise.all .

Promise.race()

This function is like Promise.all, but instead of waiting for all promises to settle, it only waits for the first one to settle and
retrieves its result or error.


Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(res => console.log(res))  // 1

Since the initial promise was the quickest to settle, it became the final outcome. Once the first promise is settled and emerges as the
winner, any subsequent results or errors are disregarded.

Promise.any()


Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(res=>console.log(res)); // 1

Although the initial promise was the quickest, it was rejected, and as a result, the second promise became the outcome. Once the first
promise that was fulfilled wins the race, any additional outcomes are disregarded.

So What is the difference between Promise. any and promise. race ?
Here's an example: imagine you have three promises that represent different tasks you want to do simultaneously. Promise 1 represents
checking your email, Promise 2 represents making a phone call, and Promise 3 represents sending a text message.

If you use Promise.race(), the method will return the result of the first promise that finishes, whether it was successful or not. So,
if Promise 1 finishes first but it's a rejection (e.g., you couldn't log in to your email), the Promise.race() method will immediately 
return the rejection value without waiting for Promise 2 or Promise 3 to finish.

If you use Promise.any(), the method will return the first promise that finishes successfully (i.e., it gets resolved). So, if Promise 
2 finishes first and it's successful (e.g., you finished your phone call), Promise. any() will return that result and Promise 1 and 
Promise 3 will stop executing. However, if none of the promises get resolved and they all reject, then Promise.any() will throw an error.